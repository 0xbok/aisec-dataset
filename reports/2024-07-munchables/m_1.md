## [M] Users can farm on zero-tax land if the landlord locked tokens before the LandManager deployment

The [`LandManager::stakeMunchable()`](repos/2024-07-munchables/src/managers/LandManager.sol#L131-L171) does not verify whether the `plotMetadata[landlord]` is set or not.

Since the `LockManager` contract is already deployed on-chain ([0xEA091311Fc07139d753A6BBfcA27aB0224854Bae (Blast)](https://blastscan.io/address/0xEA091311Fc07139d753A6BBfcA27aB0224854Bae)), accounts that have locked their tokens before the `LandManager` deployment will need to trigger `LandManager::triggerPlotMetadata()` to update their `LandManager.plotMetadata` after the `LandManager` is deployed.

The current `AccountManager` interacts with the `LockManager` on-chain but does not introduce interaction with the `LandManager` during `AccountManager::forceHarvest()`.

- On-chain: [`AccountManager::forceHarvest()`](https://blastscan.io/address/0xcee5fa48beb21dc9b3abefe414f5cb419bef940e#code#F1#L126)
- Planned upgraded version: [`AccountManager::forceHarvest()`](repos/2024-07-munchables/src/managers/AccountManager.sol#L154)

As a result, users can stake their tokens on land with a 0% tax rate if the landlord has not updated their `plotMetadata` and farm schnibbles without paying tax to the landlord until the landlord’s plot metadata is initialized in the `LandManager` contract (via `triggerPlotMetadata()` and `updatePlotMetadata()`).

```solidity
File: src/managers/LandManager.sol

131:     function stakeMunchable(
132:         address landlord,
133:         uint256 tokenId,
134:         uint256 plotId
135:     ) external override forceFarmPlots(msg.sender) notPaused {
136:         (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);
137:         if (landlord == mainAccount) revert CantStakeToSelfError();
138:         if (plotOccupied[landlord][plotId].occupied)
139:             revert OccupiedPlotError(landlord, plotId);
140:         if (munchablesStaked[mainAccount].length > 10)
141:             revert TooManyStakedMunchiesError();
142:         if (munchNFT.ownerOf(tokenId) != mainAccount)
143:             revert InvalidOwnerError();
144: 
145:         uint256 totalPlotsAvail = _getNumPlots(landlord);
146:         if (plotId >= totalPlotsAvail) revert PlotTooHighError();
147: 
148:         if (
149:             !munchNFT.isApprovedForAll(mainAccount, address(this)) &&
150:             munchNFT.getApproved(tokenId) != address(this)
151:         ) revert NotApprovedError();
152:         munchNFT.transferFrom(mainAccount, address(this), tokenId);
153: 
154:         plotOccupied[landlord][plotId] = Plot({
155:             occupied: true,
156:             tokenId: tokenId
157:         });
158: 
159:         munchablesStaked[mainAccount].push(tokenId);
160:         munchableOwner[tokenId] = mainAccount;
161: 
162:         toilerState[tokenId] = ToilerState({
163:             lastToilDate: block.timestamp,
164:             plotId: plotId,
165:             landlord: landlord,
166:@>           latestTaxRate: plotMetadata[landlord].currentTaxRate,
167:             dirty: false
168:         });
169: 
170:         emit FarmPlotTaken(toilerState[tokenId], tokenId);
171:     }
```

```solidity
File: src/managers/LandManager.sol

232:     function _farmPlots(address _sender) internal {
233:         (
234:             address mainAccount,
235:             MunchablesCommonLib.Player memory renterMetadata
236:         ) = _getMainAccountRequireRegistered(_sender);
237: 
                --- SNIPPED ---

247:         for (uint8 i = 0; i < staked.length; i++) {
                --- SNIPPED ---

280:             schnibblesTotal =
281:                 (timestamp - _toiler.lastToilDate) *
282:                 BASE_SCHNIBBLE_RATE;
283:             schnibblesTotal = uint256(
284:                 (int256(schnibblesTotal) +
285:                     (int256(schnibblesTotal) * finalBonus)) / 100
286:             );
287:             schnibblesLandlord =
288:@>           (schnibblesTotal * _toiler.latestTaxRate) / //@audit _toiler.latestTaxRate will be 0
289:                 1e18;
290: 
291:             toilerState[tokenId].lastToilDate = timestamp;
292:@>           toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]    //@audit update toilerState's latestTaxRate
293:                 .currentTaxRate;
294: 
295:@>          renterMetadata.unfedSchnibbles += (schnibblesTotal -
296:                 schnibblesLandlord);
297: 
298:             landlordMetadata.unfedSchnibbles += schnibblesLandlord;
299:             landlordMetadata.lastPetMunchable = uint32(timestamp);
300:             accountManager.updatePlayer(landlord, landlordMetadata);
301:             emit FarmedSchnibbles(
302:                 _toiler.landlord,
303:                 tokenId,
304:                 _toiler.plotId,
305:                 schnibblesTotal - schnibblesLandlord,
306:                 schnibblesLandlord
307:             );
308:         }
309:@>       accountManager.updatePlayer(mainAccount, renterMetadata);
310:     }
```

### Impact

Users can farm schnibbles on plots with a 0% tax rate without paying any tax to the landlord, which disrupts the platform's revenue model and incentives.

### Severity Clarification Aspects

- **Likelihood**: Can be considered **Medium** as there are many accounts that have locked tokens in the `LandManager`. This is evident from the fact that it was deployed over 55 days ago and the locked tokens are worth more than `$1 million` ([On-chain: `LandManager`](https://blastscan.io/address/0xEA091311Fc07139d753A6BBfcA27aB0224854Bae)).

- **Impact**: Can be considered **Medium** as it does not directly affect the landlord’s assets but results in a loss of benefits for landlords. Renters can exploit the issue by paying no tax on farming if the landlord's tax rate is not updated. Although landlords can eventually update their rates, renters can continue farming at the previous 0% tax rate until they farm again after the update.

### Proof of Concept

**Prerequisites:**

- Bob has locked tokens at the `LockManager`, with enough tokens for 10 plots.
- The `AccountManager` contract is upgraded to support the `LandManager` when `forceHarvest()` is called.
- The `LandManager` is deployed at `block-10`.

1. **`block-11`**: Alice stakes her `MunchNFT` on Bob's land with a 0% tax rate, as Bob has not triggered `LandManager::triggerPlotMetadata()` or interacted with the `LockManager` to trigger `forceHarvest()` after the `LandManager` deployment.

```solidity
    toilerState[Alice's tokenId: 10] = ToilerState({
            lastToilDate: `block-11`,
            plotId: 0,
            landlord: Bob Account,
            latestTaxRate: plotMetadata[landlord].currentTaxRate => 0,
            dirty: false
        });
```

2. **`block-12`**: Bob triggers an update to his `plotMetadata`.

```solidity
    plotMetadata[Bob Account] = PlotMetadata({
            lastUpdated: block-12,
            currentTaxRate: DEFAULT_TAX_RATE
        });
```

This `currentTaxRate` will not apply to Alice's `toilerState` until Alice farms.

3. **`block-31`**: Alice farms.

During the `schnibblesLandlord` calculation, Alice's `_toiler.latestTaxRate` (which was 0) will be used, even though Bob updated the `currentTaxRate` at `block-12`.

```solidity
File: src/managers/LandManager.sol

232:     function _farmPlots(address _sender) internal {
233:         (
234:             address mainAccount,
235:             MunchablesCommonLib.Player memory renterMetadata
236:         ) = _getMainAccountRequireRegistered(_sender);
237: 
                --- SNIPPED ---

247:         for (uint8 i = 0; i < staked.length; i++) {
                --- SNIPPED ---

280:@>           schnibblesTotal =
281:               (timestamp - _toiler.lastToilDate) *   //@audit `block-31` - `block-11`
282:                 BASE_SCHNIBBLE_RATE;
283:             schnibblesTotal = uint256(
284:                 (int256(schnibblesTotal) +
285:                     (int256(schnibblesTotal) * finalBonus)) / 100
286:             );
287:             schnibblesLandlord =
288:@>           (schnibblesTotal * _toiler.latestTaxRate) / //@audit _toiler.latestTaxRate will be 0
289:                 1e18;
290: 
291:             toilerState[tokenId].lastToilDate = timestamp;
292:@>           toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]    //@audit update toilerState's latestTaxRate
293:                 .currentTaxRate;
294: 
295:@>          renterMetadata.unfedSchnibbles += (schnibblesTotal -
296:                 schnibblesLandlord);
297: 
298:             landlordMetadata.unfedSchnibbles += schnibblesLandlord;
299:             landlordMetadata.lastPetMunchable = uint32(timestamp);
300:             accountManager.updatePlayer(landlord, landlordMetadata);
301:             emit FarmedSchnibbles(
302:                 _toiler.landlord,
303:                 tokenId,
304:                 _toiler.plotId,
305:                 schnibblesTotal - schnibblesLandlord,
306:                 schnibblesLandlord
307:             );
308:         }
309:@>       accountManager.updatePlayer(mainAccount, renterMetadata);
310:     }
```

**Result**: Alice benefits by retrieving the full `schnibblesTotal` from `block-11` until `block-31`, even though Bob updated his `plotMetadata` immediately after Alice staked.



