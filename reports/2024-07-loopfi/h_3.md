## [H] Zero rates on new quoted tokens allow an attacker to take an interest free quota

Take a look [here](repos/2024-07-loopfi/src/quotas/PoolQuotaKeeperV3.sol#L161-L177):

```solidity
function addQuotaToken(address token) external override gaugeOnly {
  if (quotaTokensSet.contains(token)) {
    revert TokenAlreadyAddedException();
  }
  quotaTokensSet.add(token); //@audit rates here are `0` by default.
  totalQuotaParams[token].cumulativeIndexLU = 1;
  emit AddQuotaToken(token);
}
```

This function is used to add a new token, when the token is added [the rates are set to `0` by default](repos/2024-07-loopfi/src/quotas/PoolQuotaKeeperV3.sol#L172) up until a general epoch update before the real rate gets set for the token [here](repos/2024-07-loopfi/src/quotas/GaugeV3.sol#L77-L92).

```solidity
function _checkAndUpdateEpoch() internal {
  uint16 epochNow = IGearStakingV3(voter).getCurrentEpoch(); // U:[GA-14]

  if (epochNow > epochLastUpdate) {
    epochLastUpdate = epochNow; // U:[GA-14]

    if (!epochFrozen) {
      // The quota keeper should call back to retrieve quota rates for needed tokens
      _poolQuotaKeeper().updateRates(); //@audit
    }

    emit UpdateEpoch(epochNow); // U:[GA-14]
  }
}
```

Which calls [this](repos/2024-07-loopfi/src/quotas/PoolQuotaKeeperV3.sol#L183-L222):

```solidity
function updateRates()
  external
  override
  gaugeOnly // U:[PQK-3]
{
  address[] memory tokens = quotaTokensSet.values();
  uint16[] memory rates = IGaugeV3(gauge).getRates(tokens); // U:[PQK-7]

  uint256 quotaRevenue; // U:[PQK-7]
  uint256 timestampLU = lastQuotaRateUpdate;
  uint256 len = tokens.length;

  for (uint256 i; i < len; ) {
    address token = tokens[i];
    uint16 rate = rates[i];

    TokenQuotaParams storage tokenQuotaParams = totalQuotaParams[token]; // U:[PQK-7]
    (uint16 prevRate, uint192 tqCumulativeIndexLU, ) = _getTokenQuotaParamsOrRevert(
      tokenQuotaParams
    );

    tokenQuotaParams.cumulativeIndexLU = QuotasLogic.cumulativeIndexSince(
      tqCumulativeIndexLU,
      prevRate,
      timestampLU
    ); // U:[PQK-7]

    tokenQuotaParams.rate = rate; // U:[PQK-7]

    quotaRevenue +=
      (IPoolV3(pool).creditManagerBorrowed(creditManagers[token]) * rate) /
      PERCENTAGE_FACTOR; // U:[PQK-7]

    emit UpdateTokenQuotaRate(token, rate); // U:[PQK-7]

    unchecked {
      ++i;
    }
  }

  IPoolV3(pool).setQuotaRevenue(quotaRevenue); // U:[PQK-7]
  lastQuotaRateUpdate = uint40(block.timestamp); // U:[PQK-7]
}
```

However, the problem is the fact that once [this new token is added](repos/2024-07-loopfi/src/quotas/PoolQuotaKeeperV3.sol#L161-L177), and the rate is `0`, an attacker can request a huge quota even up to the configured limit without having to pay any interest to the protocol all through the period where `rate = 0`.

### Impact

A malicious user can request a very high quota and not pay any interest all through the period when the rate is defaulted to `0`.



