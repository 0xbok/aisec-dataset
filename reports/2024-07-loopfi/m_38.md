## [M] `PositionAction20._onWithdraw` and `PositionPendle20._onWithdraw` also returns token amount in wrong scale

Withdraw operations will invariably revert due to insufficient funds if the collateral's decimal deviates from 18.

### Proof-of-Concept

`CDPVault.withdraw` accepts amount in `tokenScale` but returns token amount in `wad` scale.

See [`CDPVault.withdraw`](repos/2024-07-loopfi/src/CDPVault.sol#L239-L249)

```solidity
function withdraw(address to, uint256 amount) external whenNotPaused returns (uint256 tokenAmount) {
    tokenAmount = wdiv(amount, tokenScale);
    int256 deltaCollateral = -toInt256(tokenAmount);
    modifyCollateralAndDebt({
        owner: to,
        collateralizer: msg.sender,
        creditor: msg.sender,
        deltaCollateral: deltaCollateral,
        deltaDebt: 0
    });
}
```

However, the `PositionAction20._onWithdraw` and `PositionActionPendle._onWithdraw` functions expect a return value scaled to the collateral's decimal, as they use this value to transfer the token back to the collateralizer.

See [`PositionAction20._onWithdraw`](repos/2024-07-loopfi/src/proxy/PositionAction20.sol#L50-L52) and [`PositionActionPendle._onWithdraw`](repos/2024-07-loopfi/src/proxy/PositionActionPendle.sol#L45-L47)

```solidity
File: /src/proxy/PositionAction20.sol
function _onWithdraw(address vault, address position, address /*dst*/, uint256 amount) internal override returns (uint256) {
    return ICDPVault(vault).withdraw(position, amount); <-- return in wad scale
}

File: /src/proxy/PositionActionPendle.sol
function _onWithdraw(address vault, address position, address /*dst*/, uint256 amount) internal override returns (uint256) {
    return ICDPVault(vault).withdraw(address(position), amount); <-- return in wad scale
}

File: /src/proxy/PositionAction.sol
function _withdraw(address vault, address position, CollateralParams calldata collateralParams) internal returns (uint256) {
    uint256 collateral = _onWithdraw(vault, position, collateralParams.targetToken, collateralParams.amount);
    |-- the below operation will fail because it uses collateral amount in wrong scale
    v
    // perform swap from collateral to arbitrary token
    if (collateralParams.auxSwap.assetIn != address(0)) {
        _delegateCall(
            address(swapAction),
            abi.encodeWithSelector(swapAction.swap.selector, collateralParams.auxSwap)
        );
    } else {
        // otherwise just send the collateral to `collateralizer`
        IERC20(collateralParams.targetToken).safeTransfer(collateralParams.collateralizer, collateral);
    }
    return collateral;
}
```

The problem arises when collateral's decimal is not 18 (wad). For instance, let's say the collateral's decimal is 8:

- Users want to withdraw `1e8` tokens, users must call withdraw function with `amount=1e8`.
- `CDPVault.withdraw` transfer `1e8` tokens back but it returns token amount in wad, `1e18`.
- `_withdraw` will attempt to transfer `1e18` tokens which is much greater than `1e8`; therefore, the execution revert due to insufficient funds.

### Additional Notes

I want to emphasize that although this issue is similar to [WP-M2](https://notes.watchpug.com/p/190dd9d39acrEJAv#n\_3), it is not the same finding as it happens in a different code path.



