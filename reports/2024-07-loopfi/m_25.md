## [M] Incorrect address is used as `spender` for ERC20 permit signature verification

The failure of permit signature verification might revert the whole function.
`PositionAction#increaseLever()` might revert if ERC20 permit signature is used as `permitParams`

### Proof of Concept

The [`IERC20Permit(token).safePermit()`](repos/2024-07-loopfi/src/proxy/TransferAction.sol#L67-L75) call is supposed to allow `spender` to spend up to `approvalAmount` of token on behalf of `from`. The `spender` in `_transferFrom()` should be the contract itself:

```solidity
            IERC20Permit(token).safePermit(
                from,
                to,
                params.approvalAmount,
                params.deadline,
                params.v,
                params.r,
                params.s
            );
@>          IERC20(token).safeTransferFrom(from, to, amount);
```

However, `IERC20Permit(token).safePermit()` use `to` as `spender` to verify the permit signature.  The `safePermit()` call will be reverted if `to` is not same as the contract itself.

Copy below codes to [PositionAction20.t.sol](repos/2024-07-loopfi/src/test/integration/PositionAction20.lever.t.sol) and run `forge test --match-test test_increaseLeverWithInvalidPermission`:

```solidity
    function test_increaseLeverWithInvalidPermission() public {
        uint256 upFrontUnderliers = 20_000 ether;
        uint256 borrowAmount = 70_000 ether;
        uint256 amountOutMin = 69_000 ether;

        deal(address(USDC), user, upFrontUnderliers);

        // build increase lever params
        address[] memory assets = new address[](2);
        assets[0] = address(underlyingToken);
        assets[1] = address(USDC);

        LeverParams memory leverParams = LeverParams({
            position: address(userProxy),
            vault: address(vault),
            collateralToken: address(USDC),
            primarySwap: SwapParams({
                swapProtocol: SwapProtocol.UNIV3,
                swapType: SwapType.EXACT_IN,
                assetIn: address(underlyingToken),
                amount: borrowAmount,
                limit: amountOutMin,
                recipient: address(positionAction),
                deadline: block.timestamp + 100,
                args: abi.encode(weightedPoolIdArray, assets)
            }),
            auxSwap: emptySwap,
            auxAction: emptyPoolActionParams
        });

        PermitParams memory permitParams;

        uint256 deadline = block.timestamp + 100;
        //@audit-info the spender is userProxy
        (uint8 v, bytes32 r, bytes32 s) = PermitMaker.getPermitTransferFromSignature(
            address(USDC),
            address(userProxy),
            20_000 ether,
            0,
            deadline,
            0x12341234
        );
        permitParams = PermitParams({
            approvalType: ApprovalType.PERMIT,
            approvalAmount: 20_000 ether,
            nonce: 0,
            deadline: deadline,
            v: v,
            r: r,
            s: s
        });

        // call increaseLever
        vm.startPrank(user);
        //@audit-info revert due to invalid signature because `to` is used as `spender` to verify the signature, 
        //@audit-info while `to` inside the function `increaseLever()` is address(positionAction) instead of `userProxy`
        vm.expectRevert("EIP2612: invalid signature");
        userProxy.execute(
            address(positionAction),
            abi.encodeWithSelector(
                positionAction.increaseLever.selector,
                leverParams,
                address(USDC),
                20_000 ether,
                address(user),
                permitParams
            )
        );
        vm.stopPrank();
    }
```



