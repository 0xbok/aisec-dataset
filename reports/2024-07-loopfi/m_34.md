## [M] `PositionAction.sol#_deposit` incorrectly checks `auxSwap.assetIn` should be equal to `collateralParams.targetToken`

`PositionAction.sol#_deposit` incorrectly checks `auxSwap.assetIn` should be equal to `collateralParams.targetToken`. This is incorrect, because `auxSwap.assetIn` should be the token used to swap for `collateralParams.targetToken`.

### Bug Description

First, let's inspect how deposit works with swap enabled:

1. `collateralParams.collateralizer` transfers `auxSwap.assetIn` token to Proxy.
2. Proxy performs a swap (Balancer or Uniswap) to get collateral token.
3. Deposit collateral tokens.

The issue here is, during step 2, the swap is to exchange `auxSwap.assetIn` for `collateralParams.targetToken`. This means that the two tokens must not be equal. However, the current implementation checks that they are the same. This means the swap feature is completely unusable.

```solidity
    function _deposit(
        address vault,
        address position,
        CollateralParams calldata collateralParams,
        PermitParams calldata permitParams
    ) internal returns (uint256) {
        uint256 amount = collateralParams.amount;

        if (collateralParams.auxSwap.assetIn != address(0)) {
            if (
>               collateralParams.auxSwap.assetIn != collateralParams.targetToken ||
                collateralParams.auxSwap.recipient != address(this)
            ) revert PositionAction__deposit_InvalidAuxSwap();
            amount = _transferAndSwap(collateralParams.collateralizer, collateralParams.auxSwap, permitParams);
        } else if (collateralParams.collateralizer != address(this)) {
            _transferFrom(
                collateralParams.targetToken,
                collateralParams.collateralizer,
                address(this),
                amount,
                permitParams
            );
        }

        return _onDeposit(vault, position, collateralParams.targetToken, amount);
    }
```


>
> > The most common use case is to swap random input `tokenA` to `targetToken`, and deposit `targetToken` into vault. For this case, if we force `targetToken` to be `inputToken`, the swap doesn't make sense.
>
> I believe this is a valid concern. Stays as-is. The function doesn't seem to work as intended.

***

