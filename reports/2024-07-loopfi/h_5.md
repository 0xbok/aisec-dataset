## [H] There is a calculation error in `AuraVault::redeem()`

The amount of funds that users can withdraw decreases, leading to a loss of funds for users.

### Proof of Concept

```javascript
  function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public virtual override(IERC4626, ERC4626) returns (uint256) {
        require(shares <= maxRedeem(owner), "ERC4626: redeem more than max");

        // Redeem assets from Aura reward pool and send to "receiver"
@>>        uint256 assets = IPool(rewardPool).redeem(shares, address(this), address(this));

        _withdraw(_msgSender(), receiver, owner, assets, shares);

        return assets;
    }
```

We can see that `AuraVault::redeem()` confuses AuraVault’s shares with `rewardPool`’s shares. AuraVault’s shares need to be converted into AuraVault’s underlying tokens (assets) before they can be withdrawn. This is particularly problematic because, as we know from the `rewardPool` contract address, `rewardPool::redeem()` functions the same way as `rewardPool::withdraw()`.

<https://vscode.blockscan.com/ethereum/0x00A7BA8Ae7bca0B10A32Ea1f8e2a1Da980c6CAd2>

```javascript
 function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external virtual override returns (uint256) {
        return withdraw(shares, receiver, owner);
    }
```

Moreover, in the `rewardPool`, the ratio of share to asset is always 1:1.

**Scenario Example:**

Let’s assume that in `AuraVault`, the ratio of share to asset is always 1:2. In this case, if a user withdraws 1 share, they will ultimately receive only 1 asset; whereas, they should have received 2 assets.



