## [M] `INFLATION_PROTECTION_TIME` can not be up to a year as intended because it is hardcoded to `1749120350`

<relative_path_091409:src/vendor/AuraVault.sol#L66>

<relative_path_091409:src/vendor/AuraVault.sol#L301-L307>

### Impact

AURA rewards will be distributed at a lesser time than a year. In fact, if the `AuraVault.sol` contract is deployed 295 days after the completion of this audit, No aura rewards will be distributed. This is because the `INFLATION_PROTECTION_TIME` is hardcoded to `1749120350`.

### Proof of Concept

The Aura rewards is to be distributed within a year which is specified with the `INFLATION_PROTECTION_TIME` constant. However, the `INFLATION_PROTECTION_TIME` constant is hardcoded in the `AuraVault.sol` contract to `1749120350`.

```solidity
File: AuraVault.sol
66:  uint256 private constant INFLATION_PROTECTION_TIME = 1749120350;
```

And there is a validation check to distribute reward only before this `1749120350` timestamp. At the time of writing this report, there are 310 days left and after the audit there will be less than 295 days left for Aura distribution, based on the hardcoded `1749120350` `INFLATION_PROTECTION_TIME` constant.

If this `AuraVault.sol` is deployed 295 days from the time of writing this report, no AURA rewards will be distributed.

The issue lies in the fact that `INFLATION_PROTECTION_TIME` constant is hardcoded to `1749120350`, which is already decreasing the duration of rewards from a year to zero.

```solidity
File: AuraVault.sol
/**
     * @notice Allows anyone to claim accumulated rewards by depositing WETH instead
     * @param amounts An array of reward amounts to be claimed ordered as [rewardToken, secondaryRewardToken]
     * @param maxAmountIn The max amount of WETH to be sent to the Vault
     */
    function claim(uint256[] memory amounts, uint256 maxAmountIn) external returns (uint256 amountIn) {
        // Claim rewards from Aura reward pool
        IPool(rewardPool).getReward();

        // Compute assets amount to be sent to the Vault
        VaultConfig memory _config = vaultConfig;
        amountIn = _previewReward(amounts[0], amounts[1], _config);

        // Transfer assets to Vault
        require(amountIn <= maxAmountIn, "!Slippage");
        IERC20(asset()).safeTransferFrom(msg.sender, address(this), amountIn);

        // Compound assets into "asset" balance
        IERC20(asset()).safeApprove(rewardPool, amountIn);
        IPool(rewardPool).deposit(amountIn, address(this));

        // Distribute BAL rewards
        IERC20(BAL).safeTransfer(_config.lockerRewards, (amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS);
        IERC20(BAL).safeTransfer(msg.sender, amounts[0]);

        // Distribute AURA rewards
@>        if (block.timestamp <= INFLATION_PROTECTION_TIME) {
            IERC20(AURA).safeTransfer(_config.lockerRewards, (amounts[1] * _config.lockerIncentive) / INCENTIVE_BASIS);
            IERC20(AURA).safeTransfer(msg.sender, amounts[1]);
        } else {
            // after INFLATION_PROTECTION_TIME
            IERC20(AURA).safeTransfer(_config.lockerRewards, IERC20(AURA).balanceOf(address(this)));
        }

        emit Claimed(msg.sender, amounts[0], amounts[1], amountIn);
    }
```



