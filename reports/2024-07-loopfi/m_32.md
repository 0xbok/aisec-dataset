## [M] Emission schedule is not followed and can cause unexpected allocation of rewards

Whenever a new emission schedule is to be followed, i.e., `block.timestamp `becomes greater than the `startOffset` of the schedule, the `setScheduledRewardsPerSecond` function invokes the `_massUpdatePools` function in order to bring the pools to the latest state.

```solidity
    function setScheduledRewardsPerSecond() internal {
        if (!persistRewardsPerSecond) {
            uint256 length = emissionSchedule.length;
            uint256 i = emissionScheduleIndex;
            uint128 offset = uint128(block.timestamp - startTime);
            for (; i < length && offset >= emissionSchedule[i].startTimeOffset; ) {
                unchecked {
                    i++;
                }
            }
            if (i > emissionScheduleIndex) {
                emissionScheduleIndex = i;
=>              _massUpdatePools();
                rewardsPerSecond = uint256(emissionSchedule[i - 1].rewardsPerSecond);
            }
        }
```

Inside the `_massUpdatePools`, the previous `rewardsPerSecond` is used until `block.timestamp` instead of the `startOffset` of the new schedule; i.e., the correct update of `oldRewardsPerSecond * (newScheduleStartTimestamp - lastUpdateStamp) + newRewardsPerSecond * (block.timestamp - newScheduleStartTimestamp)` is not used.

`_massUpdatePools -> _updatePool -> _newRewards`

```solidity
    function _newRewards(
        VaultInfo memory pool,
        uint256 _totalAllocPoint
    ) internal view returns (uint256 newReward, uint256 newAccRewardPerShare) {
        uint256 lpSupply = pool.totalSupply;
        if (lpSupply > 0) {
            uint256 duration = block.timestamp - pool.lastRewardTime;
            uint256 rawReward = duration * rewardsPerSecond;
```



