## [M] `PoolAction::_balancerExit` returns wrong token out amount

Users use `PoolAction::exit` to exit a Balancer pool position, it calls `_balancerExit` to do the job. It is expected to exit the pool and return the amount out of the token; however, it returns the whole recipient's balance, without considering the case where the recipient is holding an amount of the same token from different sources. It'll return an exaggerated amount rather than the amount out.

This will cause `PositionAction4626::_onDecreaseLever` to revert sometimes. In this case, the user is leveraging down, exiting a Balancer pool, and holds some `tokenOut` amount. In `PositionAction::onCreditFlashLoan`, `withdrawnCollateral` would be an unreal exaggerated amount, and the contract will try to send back `residualAmount` which will be greater than its balance.

### Proof of Concept

Add the following test in `src/test/integration/PoolAction.t.sol`:

```solidity
function test_wrongBalancerExitAmount() public {
    uint256 amount = 10 ether;

    deal(wstETH, user, amount * 2);

    (uint8 v, bytes32 r, bytes32 s) = PermitMaker.getPermit2TransferFromSignature(
        address(wstETH),
        address(poolAction),
        amount,
        NONCE,
        block.timestamp,
        userPk
    );

    PermitParams[] memory permitParamsArray = new PermitParams[](3);
    permitParamsArray[1] = PermitParams(ApprovalType.PERMIT2, amount, NONCE, block.timestamp, v, r, s);

    address[] memory tokens = new address[](3);
    tokens[0] = wstETH_bb_a_WETH_BPTl;
    tokens[1] = wstETH;
    tokens[2] = bbaweth;

    uint256[] memory maxAmountsIn = new uint256[](3);
    maxAmountsIn[0] = 0;
    maxAmountsIn[1] = amount;
    maxAmountsIn[2] = 0;

    uint256[] memory tokensIn = new uint256[](2);
    tokensIn[0] = amount;
    tokensIn[1] = 0;

    uint256[] memory minAmountsOut = new uint256[](3);
    minAmountsOut[0] = 0;
    minAmountsOut[1] = 0;
    minAmountsOut[2] = 0;

    vm.startPrank(user);

    // Joins Balancer pool with 10 WSTETH
    poolAction.transferAndJoin(
        user,
        permitParamsArray,
        PoolActionParams(Protocol.BALANCER, 0, user, abi.encode(poolId, tokens, tokensIn, maxAmountsIn))
    );

    uint256 balancerLP = ERC20(wstETH_bb_a_WETH_BPTl).balanceOf(user);

    // Receives 11 Balancer LP tokens
    assertEq(balancerLP / 1 ether, 11);
    // Balance is 10 WSTETH
    assertEq(ERC20(wstETH).balanceOf(user), amount);

    // Transfer Balancer LP tokens to PoolAction
    ERC20(wstETH_bb_a_WETH_BPTl).transfer(address(poolAction), balancerLP);

    // Exits the Balancer pool
    uint256 amountOut = poolAction.exit(
        PoolActionParams(
            Protocol.BALANCER,
            0,
            user,
            abi.encode(poolId, wstETH_bb_a_WETH_BPTl, balancerLP, 0, tokens, minAmountsOut)
        )
    );

    // Amount returned by the function is 19 WSTETH instead of 9 WSTETH
    assertEq(amountOut / 1 ether, 19);
    // Balance is 19 WSTETH
    assertEq(ERC20(wstETH).balanceOf(user) / 1 ether, 19);
}
```



