## [H] `Flashlender.sol#flashLoan()` should use `mintProfit()` to mint fees, as the current implementation may lead to locked up WETH in PoolV3

When using flashlender to create loans, there is small amount of fees. The fees are sent to PoolV3 and is spread out to the lpETH stakers.

The issue is, the current implementation uses `pool.repayCreditAccount()` to add the profit, by setting the `profit == fees`. This is incorrect, and the correct implementation should be to use `pool.mintProfit()` to send the fees.

Both implementation mints the extra fees as lpETH to the `StakingLPEth.sol` contract, which is correct. However, the current implementation does NOT update the `expectedLiquidity`, since it assumes the `profit` is a part of the interest that should be paid by debt borrowers, and is already included, which is incorrect.

We can see the `mintProfit()` function also adds the amount of fees to the `expectedLiquidity`, since this is a different kind of fees than debt interest.

The impact of this issue is that the WETH amount in PoolV3 would be larger than `expectedLiquidity`. Since lpETH:WETH is always 1:1, when users want to withdraw the WETH, it may revert due to underflow when updating `expectedLiquidity`. An example is:

1. Currently there is 100 lpETH, 100 WETH, `expectedLiquidity == 100` WETH inside PoolV3.
2. Flashloan fees of 10 WETH comes in, lpETH is 110 lpETH, WETH is 110 WETH, but `expectedLiquidity` is still 100 WETH.
3. All lpETH users try to withdraw their WETH. Note that there is enough WETH in PoolV3, but since during withdraw, the `expectedLiquidity` is also updated, so only 100 WETH is allow for withdraw, or else there would be an integer underflow.

Note that CDPVault also uses `mintProfit()` to send the extra liquidation penalty as profit to PoolV3.

[src/CDPVault.sol#L569](repos/2024-07-loopfi/src/CDPVault.sol#L569)

`Flashlender.sol`:

```solidity
    function flashLoan(
        IERC3156FlashBorrower receiver,
        address token,
        uint256 amount,
        bytes calldata data
    ) external override nonReentrant returns (bool) {
        if (token != address(underlyingToken)) revert Flash__flashLoan_unsupportedToken();
        uint256 fee = wmul(amount, protocolFee);
        uint256 total = amount + fee;

        pool.lendCreditAccount(amount, address(receiver));

        emit FlashLoan(address(receiver), token, amount, fee);

        if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS)
            revert Flash__flashLoan_callbackFailed();

        // reverts if not enough Stablecoin have been send back
        underlyingToken.transferFrom(address(receiver), address(pool), total);
@>      pool.repayCreditAccount(total - fee, fee, 0);
        // @BUG. SHOULD USE pool.mintProfit().

        return true;
    }
```

`PoolV3.sol`:

```solidity
    function repayCreditAccount(
        uint256 repaidAmount,
        uint256 profit,
        uint256 loss
    )
        external
        override
        creditManagerOnly // U:[LP-2C]
        whenNotPaused // U:[LP-2A]
        nonReentrant // U:[LP-2B]
    {
        if (profit > 0) {
            _mint(treasury, convertToShares(profit)); // U:[LP-14B]
        } else if (loss > 0) {
            ...
        }
        _updateBaseInterest({
@>          expectedLiquidityDelta: -loss.toInt256(),
            availableLiquidityDelta: 0,
            checkOptimalBorrowing: false
        }); // U:[LP-14B,14C,14D]
    }

    function mintProfit(uint256 amount) external creditManagerOnly {
        _mint(treasury, amount);

        _updateBaseInterest({
@>          expectedLiquidityDelta: amount.toInt256(),
            availableLiquidityDelta: 0,
            checkOptimalBorrowing: false
        }); // U:[LP-14B,14C,14D]
    }



    function _withdraw(
        address receiver,
        address owner,
        uint256 assetsSent,
        uint256 assetsReceived,
        uint256 amountToUser,
        uint256 shares
    ) internal {
        if (msg.sender != owner) _spendAllowance({owner: owner, spender: msg.sender, amount: shares}); // U:[LP-8,9]
        _burn(owner, shares); // U:[LP-8,9]

        _updateBaseInterest({
>           expectedLiquidityDelta: -assetsSent.toInt256(),
>           availableLiquidityDelta: -assetsSent.toInt256(),
            checkOptimalBorrowing: false
        }); // U:[LP-8,9]
        // @INTEGER UNDERFLOW WOULD OCCUR HERE.

        IERC20(underlyingToken).safeTransfer({to: receiver, value: amountToUser}); // U:[LP-8,9]
        if (assetsSent > amountToUser) {
            unchecked {
                IERC20(underlyingToken).safeTransfer({to: treasury, value: assetsSent - amountToUser}); // U:[LP-8,9]
            }
        }
        emit Withdraw(msg.sender, receiver, owner, assetsReceived, shares); // U:[LP-8,9]
    }
```



