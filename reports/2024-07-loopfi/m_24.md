## [M] `lastRPS` could be set to `0` accidentally

New reward distribution can not start automatically when `lastRPS` is set to `0` accidentally.

### Proof of Concept

When [`ChefIncentivesController#claim()`](repos/2024-07-loopfi/src/reward/ChefIncentivesController.sol#L518-L550) is called to vest reward for eligible user, `_updateEmissions()` is invoked first. This function checks if the current reward distribution has ended and, if so, stores the value of `rewardsPerSecond` into `lastRPS` for future use:

```solidity
    function _updateEmissions() internal {
        if (block.timestamp > endRewardTime()) {
            _massUpdatePools();
@>          lastRPS = rewardsPerSecond;
@>          rewardsPerSecond = 0;
            return;
        }
        setScheduledRewardsPerSecond();
    }
```

When new rewards are deposited, the cached value in `lastRPS` should be restored to `rewardsPerSecond` to restart the reward distribution.

```solidity
    function registerRewardDeposit(uint256 _amount) external onlyOwner {
        depositedRewards = depositedRewards + _amount;
        _massUpdatePools();
        if (rewardsPerSecond == 0 && lastRPS > 0) {
@>          rewardsPerSecond = lastRPS;
        }
        emit RewardDeposit(_amount);
    }
```

However, if somehow `claim()` is called twice continually when the current reward distribution ends, `lastRPS` will be set to `0` and `registerRewardDeposit()` can not restart new reward distribution.

Copy below codes to [ChefIncentivesController.t.sol](repos/2024-07-loopfi/src/test/unit/ChefIncentivesController.t.sol) and run `forge test --match-test test_setLastRPStoZero`:

```solidity
    function test_setLastRPStoZero() public {
        address alice = makeAddr("alice");
        address bob = makeAddr("bob");
        _excludeContracts(alice);
        _excludeContracts(bob);
        uint rps = incentivesController.rewardsPerSecond();
        incentivesController.addPool(address(0x1), 1000);
        incentivesController.addPool(address(0x2), 1000);
        incentivesController.setRewardsPerSecond(rps, true);
        loopToken.mint(address(incentivesController), 1000 ether);
        uint256 rewardAmount = 1000 ether;
        incentivesController.registerRewardDeposit(rewardAmount);

        incentivesController.start();

        vm.warp(block.timestamp + 30 days);

        address[] memory vaults = new address[](2);
        vaults[0] = address(0x1);
        vaults[1] = address(0x2);

        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(EligibilityDataProvider.isEligibleForRewards.selector, alice),
            abi.encode(true)
        );

        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(EligibilityDataProvider.refresh.selector, alice),
            abi.encode(true)
        );

        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(EligibilityDataProvider.getDqTime.selector, alice),
            abi.encode(0)
        );

        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(EligibilityDataProvider.isEligibleForRewards.selector, bob),
            abi.encode(true)
        );

        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(EligibilityDataProvider.refresh.selector, bob),
            abi.encode(true)
        );

        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(EligibilityDataProvider.getDqTime.selector, bob),
            abi.encode(0)
        );


        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(IEligibilityDataProvider.lastEligibleStatus.selector, alice),
            abi.encode(true)
        );
        vm.mockCall(
            mockEligibilityDataProvider,
            abi.encodeWithSelector(IEligibilityDataProvider.lastEligibleStatus.selector, bob),
            abi.encode(true)
        );
        vm.prank(address(0x1));
        incentivesController.handleActionAfter(alice, 500 ether, 1000 ether);
        vm.prank(address(0x2));
        incentivesController.handleActionAfter(bob, 500 ether, 1000 ether);

        vm.warp(block.timestamp + 30 days);

        vm.mockCall(
            mockMultiFeeDistribution,
            abi.encodeWithSelector(IMultiFeeDistribution.vestTokens.selector, alice, 1000 ether),
            abi.encode(true)
        );
        vm.mockCall(
            mockMultiFeeDistribution,
            abi.encodeWithSelector(IMultiFeeDistribution.vestTokens.selector, bob, 1000 ether),
            abi.encode(true)
        );
        //@audit-info rewardsPerSecond is 1e16 before claim for alice
        assertEq(incentivesController.lastRPS(), 0);
        assertEq(incentivesController.rewardsPerSecond(), 10000000000000000);
        incentivesController.claim(alice, vaults);
        //@audit-info rewardsPerSecond is set to 0, and its previous value is stored in lastRPS for future use
        assertEq(incentivesController.lastRPS(), 10000000000000000);
        assertEq(incentivesController.rewardsPerSecond(), 0);
        incentivesController.claim(bob, vaults);
        //@audit-info however, lastRPS is updated to 0 when claim() is called again for bob.
        assertEq(incentivesController.lastRPS(), 0);
        assertEq(incentivesController.rewardsPerSecond(), 0);
        //@audit-info new reward deposit can not restart distribution
        loopToken.mint(address(incentivesController), 1000 ether);
        incentivesController.registerRewardDeposit(1000 ether);
        assertEq(incentivesController.rewardsPerSecond(), 0);
    }
```





