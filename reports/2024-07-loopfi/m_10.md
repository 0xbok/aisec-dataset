## [M] Malicious actor can abuse the minimum shares check in `StakingLPEth` and cause DoS or locked funds for the last user that withdraws

[src/StakingLPEth.sol#L141-L144](repos/2024-07-loopfi/src/StakingLPEth.sol#L141-L144)

[src/StakingLPEth.sol#L71](repos/2024-07-loopfi/src/StakingLPEth.sol#L71)

[src/StakingLPEth.sol#L112](repos/2024-07-loopfi/src/StakingLPEth.sol#L112)

### Impact

The last user that tries to cooldown/withdraw his share will not be able to withdraw the full deposited amount.

### Proof of Concept

The `StakingLpEth` contract implements a check for minimum shares to ensure that inflation attacks cannot happen:

```solidity
    function _checkMinShares() internal view {
        uint256 _totalSupply = totalSupply();
        if (_totalSupply > 0 && _totalSupply < MIN_SHARES) revert MinSharesViolation();
    }
```

The `_checkMinShares` function is called on every deposit/withdrawal to ensure that `_totalSupply` does not become less than `MIN_SHARES`:

```solidity
    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override nonReentrant {
        super._deposit(caller, receiver, assets, shares);
        _checkMinShares();
    }

    /**
     * @dev Withdraw/redeem common workflow.
     * @param caller tx sender
     * @param receiver where to send assets
     * @param _owner where to burn shares from
     * @param assets asset amount to transfer out
     * @param shares shares to burn
     */
    function _withdraw(
        address caller,
        address receiver,
        address _owner,
        uint256 assets,
        uint256 shares
    ) internal override nonReentrant {
        super._withdraw(caller, receiver, _owner, assets, shares);
        _checkMinShares();
    }
```

However, this check opens up a griefing opportunities for attackers to either make sure that the last user that tries to withdraw will only be able to withdraw (`his balance - MIN_SHARES`) locking the `MIN_SHARES` with no way of getting them out or completely DoSing the deposit/mint functionality of the vault.

### Exploitation Scenarios:

**Locking funds for the last user that withdraws/cooldowns:**

1. User1 mints `1e18` shares.
2. Attacker sees that and backruns him minting only 1 wei shares.
3. User1 tries to cooldown/withdraw all of his shares. However after `super._withdraw` function executes the new `_totalSupply` will be equal to 1 which is less than `MIN_SHARES`, which will make `_checkMinShares` function revert.
4. User2 comes and mints `1e18` shares.
5. Now that User2 deposited User1 will be able to withdraw his shares.
6. The cycle repeats of every new user waiting for the next one to deposit in order to withdraw/cooldown full amount, until the last one which will not be able to withdraw full amount leaving `MIN_SHARES` amount stuck.

**DoS of deposit/mint functionality:**

The contract calculates the share the same way as every `ERC4626` contract:

```solidity
    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {
        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);
    }
```

Since `decimalsOffset() == 0` and `totalAssets()` will equal to the balance of `lpEth` in the contract.

The calculation will be:

`f(share) = (lpEth * totalSupply + 1) / (totalLpEth() + 1)`

1. Right after deployment the attacker will transfer 0.01 lpEth to the contract without minting any shares.
2. Suppose the next user wants to deposit 1000 lpEth, which is quite a large amount.
3. His shares will be calculated as:

`(1000e18 * 0 + 1) / (0.01e18 + 1) = $100000`

Which is less than `MIN_SHARES`, which ultimately makes the function revert. The user will have to deposit `100_000_000_000_000` lpEth in order to pass the minimum shares requirement.



