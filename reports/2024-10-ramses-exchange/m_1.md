## [M] Inflated `GaugeV3` rewards when period is skipped

The `GaugeV3` contract distributes rewards based on the proportion of liquidity that each position had in range over each 1-week "period". This is calculated by `cachePeriodEarned()` in the gauge, which calls `positionPeriodSecondsInRange()` on the `RamsesV3Pool`. A key part of this calculation is the `periodCumulativesInside()` function, which computes the total seconds per liquidity within a tick range for that period.

In `periodCumulativesInside()`, one sub-case occurs when the period is in the past, and the tick range was active at the end of that period:

[Oracle.sol#L470-L550](contracts/CL/core/libraries/Oracle.sol#L470-L550):
[Oracle.sol#L469-L551](repos/2024-10-ramses-exchange/contracts/CL/core/libraries/Oracle.sol#L469-L551)
```solidity
function periodCumulativesInside(/* ... */) /* ... */ {
    // ...
    if (lastTick < tickLower) {
        // ...
    } else if (lastTick < tickUpper) {
        // ...
        if (currentPeriod <= period) {
            // ...
        } else {
            cache.secondsPerLiquidityCumulativeX128 = $.periods[period].endSecondsPerLiquidityPeriodX128;
        }
        return
            cache.secondsPerLiquidityCumulativeX128 -
            snapshot.secondsPerLiquidityOutsideLowerX128 -
            snapshot.secondsPerLiquidityOutsideUpperX128;
    } else {
        // ...
    }
}

Notice that this sub-case relies on `$.periods[period].endSecondsPerLiquidityPeriodX128`, which is meant to represent the total seconds per liquidity when the period ended. However, this value is actually more accurately described as "the seconds per liquidity at the start of the next period", which can be seen in how `_advancePeriod()` and `newPeriod()` are implemented:

[RamsesV3Pool.sol#L749-L769](contracts/CL/core/RamsesV3Pool.sol#L749-L769):
[RamsesV3Pool.sol#L749-L769](repos/2024-10-ramses-exchange/contracts/CL/core/RamsesV3Pool.sol#L749-L769)
```solidity
function _advancePeriod() /* ... */ {
    // ...
    if ((_blockTimestamp() / 1 weeks) != _lastPeriod) {
        // ...
        uint160 secondsPerLiquidityCumulativeX128 = Oracle.newPeriod(
            $.observations,
            _slot0.observationIndex,
            period
        );
        // ...
        $.periods[_lastPeriod].endSecondsPerLiquidityPeriodX128 = secondsPerLiquidityCumulativeX128;
        // ...
    }
}

[Oracle.sol:L338-L351](contracts/CL/core/libraries/Oracle.sol#L338-L351):
[Oracle.sol#L338-L351](repos/2024-10-ramses-exchange/contracts/CL/core/libraries/Oracle.sol#L338-L351)
```
function newPeriod(/* ... */) /* ... */ {
    // ...
    uint32 delta = uint32(period) * 1 weeks - 1 - last.blockTimestamp;
    secondsPerLiquidityCumulativeX128 =
        last.secondsPerLiquidityCumulativeX128 +
        ((uint160(delta) << 128) / ($.liquidity > 0 ? $.liquidity : 1));
    // ...
}

So, this means that if a period is skipped (meaning no activity happens in the pool during the period), the next time `_advancePeriod()` is called, the `endSecondsPerLiquidityPeriodX128` for the last period will be set to just before the start of the period after the skipped period. This is effectively one week after the last period actually ended. This adds extra time to the sub-case mentioned above, which leads to inflated rewards for users.

If period `p` has gauge rewards and period `p+1` has no pool activity, the reward calculation for period `p` will be inflated, allowing users to claim more tokens than they should.