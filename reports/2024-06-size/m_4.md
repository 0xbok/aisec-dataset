## [M] Inadequate checks to confirm the correct status of the sequence/`sequencerUptimeFeed` in `PriceFeed.getPrice()` contract

The `PriceFeed` contract has `sequencerUptimeFeed` checks in place to assert if the sequencer on an L2 is running but these checks are not implemented correctly. The chainlink docs say that `sequencerUptimeFeed` can return a 0 value for `startedAt` if it is called during an "invalid round".

> **startedAt:** This timestamp indicates when the sequencer changed status. This timestamp returns 0 if a round is invalid. When the sequencer comes back up after an outage, wait for the `GRACE_PERIOD_TIME` to pass before accepting answers from the data feed. Subtract startedAt from block.timestamp and revert the request if the result is less than the `GRACE_PERIOD_TIME`.
> 
> If the sequencer is up and the `GRACE_PERIOD_TIME` has passed, the function retrieves the latest answer from the data feed using the `dataFeed` object.

Please note that an **"invalid round"** is described to mean there was a problem updating the sequencer's status, possibly due to network issues or problems with data from oracles, and is shown by a `startedAt` time of 0 and `answer` is 0. Further explanation can be seen as given by an official chainlink engineer as seen here in the chainlink public discord

*Note: to view the provided image, please see the original submission.*

This makes the implemented check below in the [PriceFeed.sol#L63C1-L82C6](repos/2024-06-size/src/oracle/PriceFeed.sol) to be useless if its called in an invalid round.

```solidity
            if (block.timestamp - startedAt <= GRACE_PERIOD_TIME) { 
                revert Errors.GRACE_PERIOD_NOT_OVER();
            }
```

As `startedAt` will be 0, the arithmetic operation `block.timestamp - startedAt` will result in a value greater than `GRACE_PERIOD_TIME` (which is hardcoded to be 3600). I.e., `block.timestamp = 1719739032`, so 1719739032 - 0 = 1719739032 which is bigger than 3600. The code won't revert.

Imagine a case where a round starts, at the beginning `startedAt` is recorded to be 0, and `answer`, the initial status is set to be 0. Note that docs say that if `answer` = 0, sequencer is up, if equals to 1, sequencer is down. But in this case here, `answer` and `startedAt` can be 0 initially, until after all data is gotten from oracles and update is confirmed then the values are reset to the correct values that show the correct status of the sequencer.

From these explanations and information, it can be seen that `startedAt` value is a second value that should be used in the check for if a sequencer is down/up or correctly updated. The checks in [PriceFeed.sol#L63C1-L82C6](repos/2024-06-size/src/oracle/PriceFeed.sol) will allow for successfull calls in an invalid round because reverts don't happen if `answer == 0` and `startedAt == 0` thus defeating the purpose of having a `sequencerFeed` check to ascertain the status of the `sequencerFeed` on L2 (i.e., if it is up/down/active or if its status is actually confirmed to be either).

[PriceFeed.sol#L68C1-L76C14](repos/2024-06-size/src/oracle/PriceFeed.sol)

```solidity
            if (answer == 1) {
                // sequencer is down
                revert Errors.SEQUENCER_DOWN();
            }

            if (block.timestamp - startedAt <= GRACE_PERIOD_TIME) {
                // time since up
                revert Errors.GRACE_PERIOD_NOT_OVER();
            }
```

### Impact

Inadequate checks to confirm the correct status of the sequencer/`sequencerUptimeFeed` in `PriceFeed.getPrice()` contract will cause `getPrice()` to not revert even when the sequencer uptime feed is not updated or is called in an invalid round.



