## [M] `LiquidateWithReplacement` does not charge swap fees on the borrower

When a user places a credit sell limit order, it may be either:
1. Bought by other users.
2. Bought by the `LiquidateWithReplacement` action.

However, for case number 2, it does not charge a swap fee for the borrower, which contradicts to the swap fee definition.

### Bug Description

Let's first see how `LiquidateWithReplacement` works. There are two steps:

1. Liquidation: Liquidator sends the amount of debt `debt.futureValue` to the protocol, and receive collateral tokens as liquidation reward.
2. Buy credit: Use the original lender's `debt.futureValue` as credit to buy credit from the borrower. This way the original lender can still get the same amount of credit at the same `dueDate`. The liquidator can then take away the difference between `debt.futureValue` and the amount sent to the borrower.

Note that step 2 is the same as buying credit using the `BuyCreditMarket` function.

However, according to the [docs](https://docs.size.credit/technical-docs/governance-variables-and-fees#governance-variables-work-in-progress), all cash and credit swaps should charge swap fees on the borrower. The issue here is the swap in `LiquidateWithReplacement` does not charge swap fees.

> Protocol fee; charged to the recipient of USDC on `cash->credit` and `credit->cash` swaps. Prorated based on credit tenor (the fee is annualized).

```solidity
    function executeLiquidateWithReplacement(State storage state, LiquidateWithReplacementParams calldata params)
        external
        returns (uint256 issuanceValue, uint256 liquidatorProfitCollateralToken, uint256 liquidatorProfitBorrowToken)
    {
        emit Events.LiquidateWithReplacement(params.debtPositionId, params.borrower, params.minimumCollateralProfit);

        DebtPosition storage debtPosition = state.getDebtPosition(params.debtPositionId);
        DebtPosition memory debtPositionCopy = debtPosition;
        BorrowOffer storage borrowOffer = state.data.users[params.borrower].borrowOffer;
        uint256 tenor = debtPositionCopy.dueDate - block.timestamp;

        liquidatorProfitCollateralToken = state.executeLiquidate(
            LiquidateParams({
                debtPositionId: params.debtPositionId,
                minimumCollateralProfit: params.minimumCollateralProfit
            })
        );

        uint256 ratePerTenor = borrowOffer.getRatePerTenor(
            VariablePoolBorrowRateParams({
                variablePoolBorrowRate: state.oracle.variablePoolBorrowRate,
                variablePoolBorrowRateUpdatedAt: state.oracle.variablePoolBorrowRateUpdatedAt,
                variablePoolBorrowRateStaleRateInterval: state.oracle.variablePoolBorrowRateStaleRateInterval
            }),
            tenor
        );
>       issuanceValue = Math.mulDivDown(debtPositionCopy.futureValue, PERCENT, PERCENT + ratePerTenor);
        liquidatorProfitBorrowToken = debtPositionCopy.futureValue - issuanceValue;

        debtPosition.borrower = params.borrower;
        debtPosition.futureValue = debtPositionCopy.futureValue;
        debtPosition.liquidityIndexAtRepayment = 0;

        emit Events.UpdateDebtPosition(
            params.debtPositionId,
            debtPosition.borrower,
            debtPosition.futureValue,
            debtPosition.liquidityIndexAtRepayment
        );

        state.data.debtToken.mint(params.borrower, debtPosition.futureValue);
>       state.data.borrowAToken.transferFrom(address(this), params.borrower, issuanceValue);
        state.data.borrowAToken.transferFrom(address(this), state.feeConfig.feeRecipient, liquidatorProfitBorrowToken);
    }
```

### Proof of Concept

Say two users setup the same sell limit order.

The first user's order was bought by a user via `BuyCreditMarket`, and the second user's order was bought by `LiquidateWithReplacement`. However, the swap fee is only charged to the first user. This is unfair and is not mentioned anywhere expected in the documents.



