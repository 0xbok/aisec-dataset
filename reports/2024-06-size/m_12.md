## [M] `executeBuyCreditMarket` returns the wrong amount of cash and overestimates the amount that needs to be checked in the variable pool

When `executeBuyCreditMarket` is called and returns the cash amount, it will return the cash amount without deducting the fee. This results in overestimating the value that needs to be validated by `validateVariablePoolHasEnoughLiquidity`.

### Proof of Concept

When `executeBuyCreditMarket` is called, it will transfer `cashAmountIn - fees` to the borrower. This means the amount that needs to be available for withdrawal in the variable pool is `cashAmountIn - fees`.

[BuyCreditMarket.sol#L195](repos/2024-06-size/src/libraries/actions/BuyCreditMarket.sol)

```solidity
    function executeBuyCreditMarket(State storage state, BuyCreditMarketParams memory params)
        external
>>>     returns (uint256 cashAmountIn)
    {
        // ...

        uint256 creditAmountOut;
        uint256 fees;

        if (params.exactAmountIn) {
            cashAmountIn = params.amount;
            (creditAmountOut, fees) = state.getCreditAmountOut({
                cashAmountIn: cashAmountIn,
                maxCashAmountIn: params.creditPositionId == RESERVED_ID
                    ? cashAmountIn
                    : Math.mulDivUp(creditPosition.credit, PERCENT, PERCENT + ratePerTenor),
                maxCredit: params.creditPositionId == RESERVED_ID
                    ? Math.mulDivDown(cashAmountIn, PERCENT + ratePerTenor, PERCENT)
                    : creditPosition.credit,
                ratePerTenor: ratePerTenor,
                tenor: tenor
            });
        } else {
            creditAmountOut = params.amount;
            (cashAmountIn, fees) = state.getCashAmountIn({
                creditAmountOut: creditAmountOut,
                maxCredit: params.creditPositionId == RESERVED_ID ? creditAmountOut : creditPosition.credit,
                ratePerTenor: ratePerTenor,
                tenor: tenor
            });
        }

       // ...

>>>     state.data.borrowAToken.transferFrom(msg.sender, borrower, cashAmountIn - fees);
        state.data.borrowAToken.transferFrom(msg.sender, state.feeConfig.feeRecipient, fees);
    }
```

However, `executeBuyCreditMarket` will return `cashAmountIn`, and provide it to `validateVariablePoolHasEnoughLiquidity` and check if the variable pool have `cashAmountIn` amount of token.

[Size.sol#L178-L185](repos/2024-06-size/src/Size.sol)

```solidity
    function buyCreditMarket(BuyCreditMarketParams calldata params) external payable override(ISize) whenNotPaused {
        state.validateBuyCreditMarket(params);
>>>     uint256 amount = state.executeBuyCreditMarket(params);
        if (params.creditPositionId == RESERVED_ID) {
            state.validateUserIsNotBelowOpeningLimitBorrowCR(params.borrower);
        }
>>>     state.validateVariablePoolHasEnoughLiquidity(amount);
    }
```

[CapsLibrary.sol#L67-L72](repos/2024-06-size/src/libraries/CapsLibrary.sol)

```solidity
    function validateVariablePoolHasEnoughLiquidity(State storage state, uint256 amount) public view {
        uint256 liquidity = state.data.underlyingBorrowToken.balanceOf(address(state.data.variablePool));
        if (liquidity < amount) {
            revert Errors.NOT_ENOUGH_BORROW_ATOKEN_LIQUIDITY(liquidity, amount);
        }
    }
```

This will overestimate the amount of liquidity that needs to be available in the variable pool and could cause the call to unnecessarily revert.



