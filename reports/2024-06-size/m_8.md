## [M] Sandwich attack on loan fulfillment will temporarily prevent users from accessing their borrowed funds

The protocol does not remove borrowed token liquidity from the aave pool once a loan is initiated. It only checks if there is enough available liquidity via the `validateVariablePoolHasEnoughLiquidity()` function. A user is expected to withdraw their funds after the loan is created. This means that a malicious user can sandwich loans that exceed the available liquidity in aave by depositing liquidity in a frontrun transaction and removing it in a backrun transaction. This way a user that takes out a loan will not be able to remove their funds until there is enough available liquidity in the pool.

Also note that liquidity may become unavailable via other factors, like external users removing liquidity from aave.

### Proof of Concept

The `sellCreditMarket()` function does not remove liquidity from aave, but only checks if there is enough liquidity available via a call to `validateVariablePoolHasEnoughLiquidity()`.

[Size.sol#L194](repos/2024-06-size/src/Size.sol)

```js
    function sellCreditMarket(SellCreditMarketParams memory params) external payable override(ISize) whenNotPaused {
        state.validateSellCreditMarket(params);
        uint256 amount = state.executeSellCreditMarket(params);
        if (params.creditPositionId == RESERVED_ID) {
            state.validateUserIsNotBelowOpeningLimitBorrowCR(msg.sender);
        }
        // @audit validate liquidity after execution??
        state.validateVariablePoolHasEnoughLiquidity(amount);
    }
```

Also, the `executeSellCreditMarket()` function transfers the size protocol accounting `borrowAToken` to the borrower, instead of the underlying token itself, leaving the user to withdraw their borrowed funds in a separate transaction.

[SellCreditMarket.sol#L202](repos/2024-06-size/src/libraries/actions/SellCreditMarket.sol)

```js
    function validateSellCreditMarket(State storage state, SellCreditMarketParams calldata params) external view {
        ...
        state.data.borrowAToken.transferFrom(params.lender, msg.sender, cashAmountOut);
        state.data.borrowAToken.transferFrom(params.lender, state.feeConfig.feeRecipient, fees);
    }
```

The `validateVariablePoolHasEnoughLiquidity()` function only checks the balance of the variable pool, and does not remove liquidity:

[CapsLibrary.sol#L67](repos/2024-06-size/src/libraries/CapsLibrary.sol)

```js
    function validateVariablePoolHasEnoughLiquidity(State storage state, uint256 amount) public view {
        uint256 liquidity = state.data.underlyingBorrowToken.balanceOf(address(state.data.variablePool));
        if (liquidity < amount) {
            revert Errors.NOT_ENOUGH_BORROW_ATOKEN_LIQUIDITY(liquidity, amount);
        }
    }
```



