## [M] `withdraw()` users may can't withdraw `underlyingBorrowToken` properly

We can withdraw `underlyingCollateralToken` and `underlyingBorrowToken` by `withdraw()`:

```solidity
    function withdraw(WithdrawParams calldata params) external payable override(ISize) whenNotPaused {
        state.validateWithdraw(params);
        state.executeWithdraw(params);
@>      state.validateUserIsNotBelowOpeningLimitBorrowCR(msg.sender);
    }

    function executeWithdraw(State storage state, WithdrawParams calldata params) public {
        uint256 amount;
        if (params.token == address(state.data.underlyingBorrowToken)) {
            amount = Math.min(params.amount, state.data.borrowAToken.balanceOf(msg.sender));
            if (amount > 0) {
@>              state.withdrawUnderlyingTokenFromVariablePool(msg.sender, params.to, amount);
            }
        } else {
            amount = Math.min(params.amount, state.data.collateralToken.balanceOf(msg.sender));
            if (amount > 0) {
                state.withdrawUnderlyingCollateralToken(msg.sender, params.to, amount);
            }
        }

        emit Events.Withdraw(params.token, params.to, amount);
    }
```

From the code above we know that whether we take `underlyingCollateralToken` or `underlyingBorrowToken`
will check `validateUserIsNotBelowOpeningLimitBorrowCR()` `==>` `collateralRatio() > openingLimitBorrowCR`.

This makes sense for taking `underlyingCollateralToken`, but not for taking `underlyingBorrowToken`.

1. Taking the `underlyingBorrowToken` does not affect the `collateralRatio`.
2. The user has already borrowed the funds (with interest accrued and collateralized), it is the user's asset, and should be able to be withdrawn at will, even if it may be liquidated.
3. `openingLimitBorrowCR` is still far from being liquidated, and should not restrict the user from withdrawing the borrowed token.

### Impact

If the token is already borrowed, just stored in `Size` and not yet taken, but due to a slight price fluctuation, `validateUserIsNotBelowOpeningLimitBorrowCR()` fails but is still far from being liquidated, the user may not be able to take the borrowed token, resulting in the possibility that the user may not be able to withdraw the borrowed funds.



