## [M] Updating fee factor may create issues for the protocol

[ConfigureLogic.sol#L509-L521](repos/2024-07-benddao/src/libraries/logic/ConfigureLogic.sol#L509-L521) [InterestLogic.sol#L248](repos/2024-07-benddao/src/libraries/logic/InterestLogic.sol#L248) [InterestLogic.sol#L201-L202](repos/2024-07-benddao/src/libraries/logic/InterestLogic.sol#L201-L202)

### Impact

When the protocol fee is modified in the `Configurator` module:

- The new fee percentage will be applied to the interest collected before the fee change.
- The protocol will use the supply rate that was calculated using the old fee factor.

### Proof of Concept

The `feeFactor` parameter is used to calculate amount of interest that goes to the treasury:

```solidity
  function _accrueFeeToTreasury(
    DataTypes.AssetData storage assetData,
    DataTypes.GroupData storage groupData,
    uint256 prevGroupBorrowIndex
  ) internal {
    AccrueToTreasuryLocalVars memory vars;

    if (assetData.feeFactor == 0) {
      return;
    }

    vars.totalScaledBorrow = groupData.totalScaledCrossBorrow + groupData.totalScaledIsolateBorrow;

    //calculate the total debt at moment of the last interaction
    vars.prevTotalBorrow = vars.totalScaledBorrow.rayMul(prevGroupBorrowIndex);

    //calculate the new total debt after accumulation of the interest on the index
    vars.currTotalBorrow = vars.totalScaledBorrow.rayMul(groupData.borrowIndex);

    //debt accrued is the sum of the current debt minus the sum of the debt at the last update
    vars.totalDebtAccrued = vars.currTotalBorrow - vars.prevTotalBorrow;

>>  vars.amountToMint = vars.totalDebtAccrued.percentMul(assetData.feeFactor);

    if (vars.amountToMint != 0) {
      assetData.accruedFee += vars.amountToMint.rayDiv(assetData.supplyIndex).toUint128();
    }
```

To adjust the asset's supply rate taking into account fee collected by the treasury:

```solidity
  function updateInterestRates(
    DataTypes.PoolData storage poolData,
    DataTypes.AssetData storage assetData,
    uint256 liquidityAdded,
    uint256 liquidityTaken
  ) internal {
    ---SNIP---
    // calculate the asset supply rate
    vars.nextAssetSupplyRate = vars.nextAssetBorrowRate.rayMul(vars.assetUtilizationRate);
    vars.nextAssetSupplyRate = vars.nextAssetSupplyRate.percentMul(
      PercentageMath.PERCENTAGE_FACTOR - assetData.feeFactor
    );
>>  assetData.supplyRate = vars.nextAssetSupplyRate.toUint128();
```

A discrepancy may occur when the pool admin changes the `feeFactor`. The new `feeFactor` will be applied to interest collected before the `feeFactor` was updated:

```solidity
function updateInterestIndexs(
    DataTypes.PoolData storage /*poolData*/,
    DataTypes.AssetData storage assetData
  ) internal {
    ---SNIP---
    for (vars.i = 0; vars.i < vars.assetGroupIds.length; vars.i++) {
      vars.loopGroupId = uint8(vars.assetGroupIds[vars.i]);
      DataTypes.GroupData storage loopGroupData = assetData.groupLookup[vars.loopGroupId];
      vars.prevGroupBorrowIndex = loopGroupData.borrowIndex;
      _updateBorrowIndex(assetData, loopGroupData);
>>    _accrueFeeToTreasury(assetData, loopGroupData, vars.prevGroupBorrowIndex);
    }

    // save updating time
    assetData.lastUpdateTimestamp = uint40(block.timestamp);
  }
```

But the protocol will still use the old supply rate that was calculated using the previous `feeFactor`. This may cause inconsistencies in the fee accounting for the protocol.



