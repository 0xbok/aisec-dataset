## [M] Risk of mass liquidation after pool/asset pause and unpause, due to borrow interest compounding implementation

Current pausing features allow a pool to be globally paused (all assets borrow, repay, liquidation pausing) and asset pausing (specific asset borrow, repay, liquidation pausing). See [`validatePoolBasic()`](relative_path_091409:src/libraries/logic/ValidateLogic.sol#L29) and [`validateAssetBasic()`](relative_path_091409:src/libraries/logic/ValidateLogic.sol#L43) which are checked in borrow, [repay](relative_path_091409:src/libraries/logic/ValidateLogic.sol#L281-L282), and will revert if the pool or the asset is paused.

The problem is the borrow interest compounding implementation (`InterestLogic::_updateBorrowIndex`) will not factor in the duration of pausing when a user cannot repay a loan.

```solidity
//src/libraries/logic/InterestLogic.sol
  function _updateBorrowIndex(DataTypes.AssetData storage assetData, DataTypes.GroupData storage groupData) internal {
    // borrow index only gets updated if there is any variable debt.
    // groupData.borrowRate != 0 is not a correct validation,
    // because a positive base variable rate can be stored on
    // groupData.borrowRate, but the index should not increase
    if ((groupData.totalScaledCrossBorrow != 0) || (groupData.totalScaledIsolateBorrow != 0)) {
        //@audit Case: asset paused and unpaused, assetData.lastUpdateTimestamp will be a timestamp before paused, interests compound during pausing 
|>      uint256 cumulatedBorrowInterest = MathUtils.calculateCompoundedInterest(
        groupData.borrowRate,
        assetData.lastUpdateTimestamp
      );
      uint256 nextBorrowIndex = cumulatedBorrowInterest.rayMul(groupData.borrowIndex);
      groupData.borrowIndex = nextBorrowIndex.toUint128();
    }
  }
```

relative_path_091409:src/libraries/logic/InterestLogic.sol#L281

Interests continuously compound with no repayment allowed. When unpaused, many accounts are vulnerable to immediate liquidation out of users' control.



