## [M] Staking ETH incorrectly assumes revert bubbling

When `EbtcLeverageZapRouter::openCdpWithEth` and `EbtcLeverageZapRouter::adjustCdpWithEth` stake ETH with Lido, the underlying function performing the call assumes that any exceptions (from Lido) will be bubbled up, but with call being a low level rather than a Solidity function, it is not the case.

Lido stETH has two cases where a revert on depositing ETH for staking may be encountered, when deposits are paused or when staking limits are enabled and it is exceeded.

If Lido returns a revert it is ignored and the entire CDP flow continues (permits, flash loans, account synching, CDP initialization, eBTC minting), with a revert only being cause only by one of the last step of the flow, moving the collateral to the active pool.

### Proof of Concept

The two parts to the issue:
1. Any possibility of reverts during staking ETH with Lido.
2. Incorrect assumption that revert would bubble.

**1. Lido deposit could revert:**

Lido has pausable staking on [Ethereum stETH](<https://etherscan.io/address/0x17144556fd3424edc8fc8a4c940b2d04936d17eb#code#F1#L324>)

```solidity
    /**
     * @notice Stops accepting new Ether to the protocol
     *
     * @dev While accepting new Ether is stopped, calls to the `submit` function,
     * as well as to the default payable function, will revert.
     *
     * Emits `StakingPaused` event.
     */
    function pauseStaking() external {
```

Lido can impose a per block stake limit on [Ethereum stETH](https://etherscan.io/address/0x17144556fd3424edc8fc8a4c940b2d04936d17eb#code#F1#L368)

```solidity
     * @dev Reverts if:
     * - `_maxStakeLimit` == 0
     * - `_maxStakeLimit` >= 2^96
     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`
     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)
     *
     * Emits `StakingLimitSet` event
     *
     * @param _maxStakeLimit max stake limit value
     * @param _stakeLimitIncreasePerBlock stake limit increase per single block
     */
    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {
```

Both these cause the same effect; a possible revert during the submit of ETH for staking with [Ethereum stETH](https://etherscan.io/address/0x17144556fd3424edc8fc8a4c940b2d04936d17eb#code#F1#L922):

```solidity
    function _submit(address _referral) internal returns (uint256) {
        require(msg.value != 0, "ZERO_DEPOSIT");

        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();
        // There is an invariant that protocol pause also implies staking pause.
        // Thus, no need to check protocol pause explicitly.
@>      require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");

        if (stakeLimitData.isStakingLimitSet()) {
            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();

@>          require(msg.value <= currentStakeLimit, "STAKE_LIMIT");
```

**2. Incorrect assumption that revert would bubble:**

`EbtcLeverageZapRouter` and `EbtcZapRouter` both use the same ancestor function to stake ETH with Lido,
that performs the `call` operation on a `address` in [`ZapRouterBase::_depositRawEthIntoLido`](relative_path_091409:ebtc-zap-router/src/ZapRouterBase.sol#L34-L41)

```solidity
    function _depositRawEthIntoLido(uint256 _initialETH) internal returns (uint256) {
        // check before-after balances for 1-wei corner case
        uint256 _balBefore = stEth.balanceOf(address(this));
        // TODO call submit() with a referral?
@>      payable(address(stEth)).call{value: _initialETH}("");
        uint256 _deposit = stEth.balanceOf(address(this)) - _balBefore;
        return _deposit;
    }
```

As outlined in [Solidity by Example - call](https://solidity-by-example.org/call/)

```text
call is a low level function to interact with other contracts.

This is the recommended method to use when you're just sending Ether via calling the fallback function.

However, it is not the recommended way to call existing functions.
Few reasons why low-level call is not recommended

    Reverts are not bubbled up
    Type checks are bypassed
    Function existence checks are omitted
```

`EbtcZapRouter` does check the collateral balance in the function that follows the staking of ETH with Lido in [`EbtcZapRouter::_openCdpWithPermit()`](relative_path_091409:ebtc-zap-router/src/EbtcZapRouter.sol#L444-L447)

```require
        require(
            stEth.balanceOf(address(this)) >= _stEthBalance,
            "EbtcZapRouter: not enough collateral for open!"
        );
```

`EbtcLeverageZapRouter` performs no similar checks on the collateral balance after the staking, rather failing on a ERC20 transfer after another \~320K gas of other operations.

### Test Case

Adds a pause to the `CollateralTokenTester` and demonstrates the non-propagation of the initial revert, instead relying on the later ERC20 revert.

The `CollateralTokenTester` mocks `Lido stETH`, add the following to the version used by the `ebtc-zap-router` tests (should be at `/lib/ebtc/packages/contracts/TestContracts/CollateralTokenTester.sol`):

```diff 
-    function deposit() public payable {
+    bool private depositsArePaused;
+
+    function pauseDeposits() external {
+        depositsArePaused = true;
+    }
+
+    function deposit() public payable {
+        require(!depositsArePaused, "STAKING_PAUSED");
```

Add to [LeverageZaps](relative_path_091409:ebtc-zap-router/test/LeverageZaps.t.sol#L534):

```solidity
    function test_ZapOpenCdp_WithEth_LidoRReverts() external {
        seedActivePool();

        // Pausing deposits to mimic Lido's pauseStaking() or stakeLimit being set & exceeded
        CollateralTokenTester(collateral).pauseDeposits();

        // Logic equivalent to that from createLeveragedPosition(MarginType.ETH)
        // Extracted to test correctly using expectRevert()
        address user = vm.addr(userPrivateKey);
        uint256 _debt = 1e18;
        uint256 flAmount = _debtToCollateral(_debt);
        uint256 marginAmount = 5 ether;
        vm.deal(user, type(uint96).max);
        IEbtcZapRouter.PositionManagerPermit memory pmPermit = createPermit(user);
        vm.prank(user);

        // Fails on the last step of BorrowerOperations::_openCdp(); transfer of collateral to the active pool
        vm.expectRevert("ERC20: transfer amount exceeds balance");
        _openTestCdp(MarginType.ETH, _debt, flAmount, marginAmount, pmPermit);
    }
```

Run with `forge test --match-contract LeverageZaps --match-test test_ZapOpenCdp_WithEth_LidoRReverts`.



