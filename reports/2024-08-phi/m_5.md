## [M] Lack of data validation when users are claiming their art allows malicious user to bypass signature/merkle hash to provide unapproved `ref_`, `artId_` and `imageURI`

In the file `PhiFactory.sol`, the lack of checks in `merkleClaim` allows malicious users to bypass the hash check to pass in their own parameter of choice. The 3 variables that could possibly be manipulated (`referral`, `artId` and `imageURI`) and their impact will be each discussed below.

### Missing `ref_` and `artId_` in validation.

As we can see in `merkleClaim`, `address ref_` and `uint256 artId_` is decoded from `encodeData_` which is simply a bytes data type passed into the function parameter by the user.

[PhiFactory.sol#L362-L375](src/PhiFactory.sol#L362-L375):
```solidity
  (address minter_, address ref_, uint256 artId_) = abi.decode(encodeData_, (address, address, uint256));
  PhiArt storage art = arts[artId_];
  ......
  if (
      !MerkleProofLib.verifyCalldata(
          proof_, credMerkleRootHash, keccak256(bytes.concat(keccak256(abi.encode(minter_, leafPart_))))
      )
  ) {
      revert InvalidMerkleProof();
  }
  ......
```

Observing the line where the merkle hash is cross-checked:

```solidity
!MerkleProofLib.verifyCalldata( proof_, credMerkleRootHash, keccak256(bytes.concat(keccak256(abi.encode(minter_, leafPart_)))) )
```

It becomes clear that **only** `minter_` from `encodeData_` is checked, leaving `ref_` and `artId_` to whatever values passed by the user.

By the way, **both** `ref_` and `artId_` are **explicitly checked in the `signatureClaim` function**:

[PhiFactory.sol#L327-L346](src/PhiFactory.sol#L327-L346):
```solidity
function signatureClaim(.....) external payable whenNotPaused {
  (uint256 expiresIn_, address minter_, address ref_, address verifier_, uint256 artId_,, bytes32 data_) =
      abi.decode(encodeData_, (uint256, address, address, address, uint256, uint256, bytes32));

  if (expiresIn_ <= block.timestamp) revert SignatureExpired();
  if (_recoverSigner(keccak256(encodeData_), signature_) != phiSignerAddress) revert AddressNotSigned();
  .....
}
```

Hence, to forge `ref_` and `artId_`, malicious users will have to use `merkleClaim` instead of `signatureClaim`.

**Impact of forging `ref_`**

- Malicious users can pass in their own other account address as `ref_`, successfully stealing the referral fee from the real `ref_` or the artist(who will receive the referral fee if `ref_` is set to null).
- Suppose Alice has 2 accounts, when she calls `merkleClaim` to claim on `account 1`, she can pass in `account 2` as the `ref_` to illegally steal the referral fees to offset the cost of minting.
- The reason why Alice has to pass in `account 2` instead of `account 1` as the `ref_` is because in `PhiRewards.sol`'s `depositRewards`, referral has to be different from minter address in order for Alice to receive the referral fees.

**Impact of forging `artId_`**

- Unlike `signatureClaim` which checks `artId_` explicitly, `merkleClaim` only verifies `minter_` and `leafPart_` to the credId's merkle root hash.
- Since a Cred can have multiple art linked to it, this becomes a problem.
- Suppose `Cred A` has `Art 1` and `Art 2`.
- Now, Alice got approval to claim `Art 1`.
- If the art's verification type was set to "SIGNATURE" and Alice had to call `signatureClaim`, Alice would **only** be able to claim `Art 1` with that approval signature.
- However if the art's verification type was "MERKLE" instead, when she calls `merkleClaim`, she will be able to claim `Art 2` with only approval for `Art 1` by passing the `artId_` of `Art 2`.

### Missing `imageURI` in validation

We can see in both `signatureClaim` [Line 330](src/PhiFactory.sol#L330) and `merkleClaim` [Line 355](src/PhiFactory.sol#L355), `imageURI` is passed into the function parameter rather than extracted from the signature and is not involved in the merkle hash check as well.

Since `imageURI` contains important information about the art details (such as location/directory). This could have a severe impact. When the malicious user is trying to claim an art that he has permission to, he could pass in an `imageURI` with the location directory of the picture image file pointing to another art which he does not have permission for.

The line `advancedTokenURI[tokenId_][to_] = imageURI_;` in `PhiNFT1155.sol` will also be set to an unapproved value. This will lead to undefined/unsupported behaviours when interacting with the smart contract regarding trying to render an user's art URI.
