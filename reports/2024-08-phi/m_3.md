## [M] `PhiFactory:claim` potentially causing loss of funds if `mintFee` changed beforehand

If the `mintFee` was lowered by the Art creator via `updateArtSettings` before the `claim` was executed, the `msg.value` from user would become larger than the updated value of `mintFee`. As the function does not validate `msg.value` and consumes the `mintFee` directly, the excess ETH sent by the user will not be refunded, causing a loss of funds for user.

If `PhiFactory` still holds positive ETH balance, a malicious user can exploit this by sending less `msg.value` than expected (or no ETH at all). This results in `PhiFactory`'s ETH being used for the `mintFee` payment instead, causing a loss for the protocol.

### Proof of Concept

This external call to `this.merkleClaim` forwards the `mintFee` value of ETH without validating it against `msg.value`.

[PhiFactory.sol#L282-L283](src/PhiFactory.sol#L282-L283):
```solidity
    264:    function claim(bytes calldata encodeData_) external payable {
        ...
    282:            uint256 mintFee = getArtMintFee(artId, quantity_);
    283: =>             this.merkleClaim{ value: mintFee }(proof, claimData, mintArgs, leafPart_);
    284:        } else if (art.verificationType.eq("SIGNATURE")) {
        ...
    304:    }
```

Similarly, this external call to `this.signatureClaim` forwards the `mintFee` value of ETH without validating it against `msg.value`.

[PhiFactory.sol#L299-L300](src/PhiFactory.sol#L299-L300):
```solidity
    264:    function claim(bytes calldata encodeData_) external payable {
        ...
    299:            uint256 mintFee = getArtMintFee(artId, quantity_);
    300: =>             this.signatureClaim{ value: mintFee }(signature_, claimData, mintArgs);
    301:        } else {
        ...
    304:    }
```

Although the `merkleClaim` and `signatureClaim` functions can process refunds, the `claim` function calls of these two functions `externally` (defined as `external` instead of `public`), results in the `msg.value` being overridden by the `mintFee`. As a result, the original `msg.value` sent to `claim()` remains unvalidated and become vulnerable to exploits.
