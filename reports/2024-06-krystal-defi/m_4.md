## [M] The Protocol breaks the Allowance Mechanism of the NFTs

[Common.sol#L392](repos/2024-06-krystal-defi/src/Common.sol#L392)

[V3Utils.sol#L76-L85](repos/2024-06-krystal-defi/src/V3Utils.sol#L76-L85)

[V3Utils.sol#L171](repos/2024-06-krystal-defi/src/V3Utils.sol#L171)

[V3Automation.sol#L92](repos/2024-06-krystal-defi/src/V3Automation.sol#L92)

### Impact

The user loses their approved entities

### Proof of Concept

The protocol transfers the Position NFT from the position owner to the protocol and back to the position owner to execute the actions.

List of occurrences

[Common.sol#L402](repos/2024-06-krystal-defi/src/Common.sol#L402)
```solidity
        params.nfpm.transferFrom(address(this), params.recipient, result.tokenId);

[V3Utils.sol#L171](repos/2024-06-krystal-defi/src/V3Utils.sol#L171)
```solidity
        nfpm.transferFrom(address(this), from, tokenId);

[V3Utils.sol#L76-L85](repos/2024-06-krystal-defi/src/V3Utils.sol#L76-L85)
```solidity
    function execute(INonfungiblePositionManager _nfpm, uint256 tokenId, Instructions calldata instructions)  whenNotPaused() external
    {
        // must be approved beforehand
        _nfpm.safeTransferFrom(
            msg.sender,
            address(this),
            tokenId,
            abi.encode(instructions)
        );
    }
```
[V3Automation.sol#L92](repos/2024-06-krystal-defi/src/V3Automation.sol#L92)
```solidity
        params.nfpm.transferFrom(positionOwner, address(this), params.tokenId);
```

[V3Automation.sol#L167](repos/2024-06-krystal-defi/src/V3Automation.sol#L167)
```solidity
        params.nfpm.transferFrom(address(this), positionOwner, params.tokenId);
```
This breaks the allowance mechanism of ERC721 for every action taken on the platform and it omits the allowances given from the token owners to the approved entities.

For every NFT transfer, the allowances are zeroed out:

```solidity
Contract: ERC721.sol

333:     function _transfer(address from, address to, uint256 tokenId) internal virtual {
334:         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
335:         require(to != address(0), "ERC721: transfer to the zero address");
336:
337:         _beforeTokenTransfer(from, to, tokenId, 1);
338:
339:         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
340:         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
341:
342:         // Clear approvals from the previous owner
343:   >>    delete _tokenApprovals[tokenId];
344:
345:         unchecked {
346:             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
347:             // `from`'s balance is the number of token held, which is at least one before the current
348:             // transfer.
349:             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
350:             // all 2**256 token ids to be minted, which in practice is impossible.
351:             _balances[from] -= 1;
352:             _balances[to] += 1;
353:         }
354:         _owners[tokenId] = to;
355:
356:         emit Transfer(from, to, tokenId);
357:
358:         _afterTokenTransfer(from, to, tokenId, 1);
359:     }
```

E.g.:

1.  Alice is on her flight to attend DSS Bangkok
2.  She already approved Bob to take care of her positions until she arrives during the long flight
3.  Bob interacts with Krystal to collect the LP fees.
4.  Bob loses his approval
5.  AliceÂ´s position remains unattended and one of the pool tokens takes a nose dive before Bob can withdraw the liquidity and sell it.



