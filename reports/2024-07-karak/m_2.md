## [M] A snapshot may face a permanent DoS if both a slashing event occurs in the `NativeVault` and the staker's validator is penalized

[NativeVault.sol#L126-L162](repos/2024-07-karak/src/NativeVault.sol#L126-L162)
[NativeVault.sol#L476-L495](repos/2024-07-karak/src/NativeVault.sol#L476-L495)
[NativeVault.sol#L517-L525](repos/2024-07-karak/src/NativeVault.sol#L517-L525)
[NativeVault.sol#L507-L515](repos/2024-07-karak/src/NativeVault.sol#L507-L515)

### Impact

The staker can still receive rewards even if their validators are empty.

### Proof of Concept

Let's consider the following scenario:

1.  Alice has a validator whose balance is 32 ETH.

2.  A slashing event occurs in the NativeVault, resulting in Alice being slashed by 2 ETH, reducing her withdrawable assets to 30 ETH.

3.  Subsequently, Alice's validator loses all its funds (this can happen within the 7-day snapshot period, even within just 1 hour). A snapshot should then be taken to reduce Alice's assets by 32 ETH, which requires calling the `validateSnapshotProofs()` function for Alice's validator.

    ```solidity
        function validateSnapshotProofs(
            address nodeOwner,
            BeaconProofs.BalanceProof[] calldata balanceProofs,
            BeaconProofs.BalanceContainer calldata balanceContainer
        )
            external
            nonReentrant
            nodeExists(nodeOwner)
            whenFunctionNotPaused(Constants.PAUSE_NATIVEVAULT_VALIDATE_SNAPSHOT)
        {
            NativeVaultLib.Storage storage self = _state();
            NativeVaultLib.NativeNode storage node = self.ownerToNode[nodeOwner];
            NativeVaultLib.Snapshot memory snapshot = node.currentSnapshot;

            if (node.currentSnapshotTimestamp == 0) revert NoActiveSnapshot();

            BeaconProofs.validateBalanceContainer(snapshot.parentBeaconBlockRoot, balanceContainer);

            for (uint256 i = 0; i < balanceProofs.length; i++) {
                NativeVaultLib.ValidatorDetails memory validatorDetails =
                    node.validatorPubkeyHashToDetails[balanceProofs[i].pubkeyHash];

                if (validatorDetails.status != NativeVaultLib.ValidatorStatus.ACTIVE) revert InactiveValidator();
                if (validatorDetails.lastBalanceUpdateTimestamp >= node.currentSnapshotTimestamp) {
                    revert ValidatorAlreadyProved();
                }

    153         int256 balanceDeltaWei = self.validateSnapshotProof(
                    nodeOwner, validatorDetails, balanceContainer.containerRoot, balanceProofs[i]
                );

                snapshot.remainingProofs--;
    158         snapshot.balanceDeltaWei += balanceDeltaWei;
            }

    161     _updateSnapshot(node, snapshot, nodeOwner);
        }
    ```

    In this call, `snapshot.balanceDeltaWei` is set to -32 ETH, and the `_updateSnapshot()` function is invoked at `L161`.

4.  In the `_updateSnapshot()` function, the `_updateBalance()` function is invoked at `L490`, with `totalDeltaWei = -32 ETH`, as noted at `L482`.
    ```solidity
        function _updateSnapshot(
            NativeVaultLib.NativeNode storage node,
            NativeVaultLib.Snapshot memory snapshot,
            address nodeOwner
        ) internal {
            if (snapshot.remainingProofs == 0) {
    482         int256 totalDeltaWei = int256(snapshot.nodeBalanceWei) + snapshot.balanceDeltaWei;

                node.withdrawableCreditedNodeETH += snapshot.nodeBalanceWei;

                node.lastSnapshotTimestamp = node.currentSnapshotTimestamp;
                delete node.currentSnapshotTimestamp;
                delete node.currentSnapshot;

    490         _updateBalance(nodeOwner, totalDeltaWei);
                emit SnapshotFinished(nodeOwner, node.nodeAddress, node.lastSnapshotTimestamp, totalDeltaWei);
            } else {
                node.currentSnapshot = snapshot;
            }
        }
    ```

5.  Within the `_updateBalance()` function, the `_decreaseBalance()` function is called at `L521` with a decrease amount of 32 ETH.
    ```solidity
        function _updateBalance(address _of, int256 assets) internal {
            if (assets > 0) {
                _increaseBalance(_of, uint256(assets));
            } else if (assets < 0) {
    521         _decreaseBalance(_of, uint256(-assets));
            } else {
                return;
            }
        }
    ```

6.  In the `_decreaseBalance()` function, shares are burned at `L511`.
    ```solidity
        function _decreaseBalance(address _of, uint256 assets) internal {
            NativeVaultLib.Storage storage self = _state();
            uint256 shares = previewWithdraw(assets);
            _beforeWithdraw(assets, shares);
    511     _burn(_of, shares);
            self.totalAssets -= assets;
            self.ownerToNode[_of].totalRestakedETH -= assets;
            emit DecreasedBalance(self.ownerToNode[_of].totalRestakedETH);
        }
    ```

The problem arises in step 6. Here, the shares being burned correspond to 32 ETH, while Alice's shares only amount to 30 ETH. This discrepancy causes the burn amount to exceed the existing share amount, leading to a reversal of the transaction. As a result, the snapshot for Alice will be permanently `DoS`ed, and her share amount will remain unchanged. Consequently, Alice can still receive rewards even though her validator is empty. In addition, nobody can call `validateExpiredSnapshot()` for Alice.

A malicious staker could intentionally orchestrate this scenario by creating a validator and engaging in malicious behavior. If the malicious action fails, they would lose all 32 ETH but could still receive rewards.



