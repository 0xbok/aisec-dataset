## [M] Broken assumptions can lead to the inability to seize RSR

The `seizeRSR` [function](repos/2024-07-reserve/contracts/p1/StRSR.sol#L424) takes RSR from the staking contract when `BackingManager` wants to sell RSR, [but it does not have enough](repos/2024-07-reserve/contracts/p1/BackingManager.sol#L161). In this case, the stakers can lose a portion of their stake in order to keep the system healthy. However, an issue arises from broken assumptions about `stakeRSR` and `totalStakes`, which will make the contract unable to seize due to revert.

### Proof of Concept

Let's assume the system becomes unhealthy, and the stakers will start unstaking their tokens in fear of an upcoming reset/seize. Then, the expected event comes, and the `BackingManager` tries to seize RSR from the staking contract.

This action is frontran however, with the last staker who:

1.  unstakes everything
2.  stakes one token
3.  stakes one token again

Let's examine how does this break `seizeRSR`.

1.  During the `unstake` [call](repos/2024-07-reserve/contracts/p1/StRSR.sol#L259):
    *   `_payoutRewards` is called. Since `totalStakes` is still above `1e18`, `stakeRSR` can be increased and become greater than `totalStakes`. Let's assume that `totalStakes` would be `1000e18` and `stakeRSR` would end at `1001e18` after this step.
    *   Now, the `stakeRate` would be updated. Since `stakeRSR` is not zero yet, and so is not `totalStakes`, it would be set to
        [StRSR.sol#L423-L500](repos/2024-07-reserve/contracts/p1/StRSR.sol#L423-L500)
```solidity
          uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR)
        which translates to
        ```solidity
          uint192((1000e18 * 1e18 + (1001e18 - 1)) / 1001e18)
        resulting in `999000999000999001`
    *   `totalStakes` would be decreased in `_burn` by `1000e18` to zero, which would result in `stakeRSR` being set to zero
2.  During the `stake` [call](repos/2024-07-reserve/contracts/p1/StRSR.sol#L227):
    *   `payoutRewards` is skipped because it was already called in this block
    *   `newTotalStakes` in `mintStakes` is calculated as `(stakeRate * newStakeRSR) / FIX_ONE`, which translates to `(stakeRate * (stakeRSR + rsrAmount)) / FIX_ONE` which translates to `(999000999000999001 * (0 + 1)) / 1e18` resulting in 0, meaning 0 tokens are minted and `totalStakes` remains 0
    *   `stakeRSR` is increased by 1
3.  The second `stake` call will have the same effects
    *   after this call, the `stakeRate` is `999000999000999001`, `totalStakes` is 0, and `stakeRSR` is 2 (note that this breaks [this assumption](repos/2024-07-reserve/contracts/p1/StRSR.sol#L619-L620))
4.  Now we examine the important parts of the `seizeRSR` call
    *   `stakeRSRToTake` is set to `(2 * rsrAmount + (rsrBalance - 1)) / rsrBalance`, which will result in 1 every time the we are not seizing more than half of the total balance of the contract
    *   `stakeRSR` is therefore set to 1, and since it is non-zero, `stakeRate` is updated to `uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR)`, which translates to `uint192((1e18 * 0 + (1 - 1)) / 1)` which comes to 0
    *   the rest of the call is not important until it comes to
        ```Solidity
        emit ExchangeRateSet(initRate, exchangeRate());
        ```
    *   Here, we can see that the call returns
        ```solidity
        return (FIX_SCALE_SQ + (stakeRate / 2)) / stakeRate;
    *   since `stakeRate` was updated to 0 before, the call will revert

### Impact and Likelihood

The likelihood of this issue is **LOW**. The impact seems somewhere between **HIGH** and **MEDIUM** since a necessary rebalance action can be DoSed until it is noticed and an action is taken. Considering that the issue is possible due to a broken invariant, the severity should be judged as **MEDIUM**.



