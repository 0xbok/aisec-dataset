## [M] The time available for a canceled withdrawal should not impact future unstaking processes

### Lines of Code

[StRSR.sol#L279](repos/2024-07-reserve/contracts/p1/StRSR.sol#L279)
[StRSR.sol#L658](repos/2024-07-reserve/contracts/p1/StRSR.sol#L658)
[StRSR.sol#L368](repos/2024-07-reserve/contracts/p1/StRSR.sol#L368)

### Impact

When `stakers` want to `unstake` their `StRSR`, they cannot `withdraw` `RSR` immediately.
Instead, each `withdrawal` enters a `queue` and will become available after the `unstaking delay` period.
This `queue` operates on a `FIFO` basis, meaning earlier `withdrawals` are processed before later ones.
`Stakers` can also cancel their `withdrawals`, and the `RSR` will be `restaked` immediately.
However, even canceled `withdrawals` can still impact future `withdrawal` requests.

### Proof of Concept

Suppose the current `unstakingDelay` is set to `1 day`, and a user decides to `unstake` some amount of `StRSR` at time `T` (`line 279`).

    function unstake(uint256 stakeAmount) external {
        address account = _msgSender();
        require(stakes[era][account] >= stakeAmount, "insufficient balance");
        _payoutRewards();
        _burn(account, stakeAmount);

        uint256 newStakeRSR = (FIX_ONE_256 * totalStakes + (stakeRate - 1)) / stakeRate;
        uint256 rsrAmount = stakeRSR - newStakeRSR;
        stakeRSR = newStakeRSR;

    279:    (uint256 index, uint64 availableAt) = pushDraft(account, rsrAmount);
    }

This request enters a `queue`, which we assume is empty at this point, making the `withdrawal` available at `T + 1 day` (`line 658`).

    function pushDraft(address account, uint256 rsrAmount)
        internal
        returns (uint256 index, uint64 availableAt)
    {
        CumulativeDraft[] storage queue = draftQueues[draftEra][account];
        index = queue.length;  // index = 0

        uint192 oldDrafts = index != 0 ? queue[index - 1].drafts : 0; // 0
        uint64 lastAvailableAt = index != 0 ? queue[index - 1].availableAt : 0; // 0
    658:    availableAt = uint64(block.timestamp) + unstakingDelay; // T + 1 day

        if (lastAvailableAt > availableAt) {
            availableAt = lastAvailableAt;
        }
        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));
    }

Now, let's assume the user `cancels` this `withdrawal` at time `T` for testing purposes. Instead of removing the `withdrawal` from the `queue`, we simply increase the `first available ID`, which is a good approach and is easy to implement (`line 368`).

    function cancelUnstake(uint256 endId) external {
        uint256 firstId = firstRemainingDraft[draftEra][account];
        CumulativeDraft[] storage queue = draftQueues[draftEra][account];
        if (endId == 0 || firstId >= endId) return;

        require(endId <= queue.length, "index out-of-bounds");

    368:    firstRemainingDraft[draftEra][account] = endId;
    }

Even though the `queue` technically still contains one item (the `canceled` `withdrawal` request), we can consider the `queue` empty in terms of available `withdrawals`.

Later, the owner updates the `unstakingDelay` to `1 hour`.
The user attempts to `unstake` again, expecting to `withdraw` just `1 hour` later, which should be possible.
However, the canceled `withdrawal` still impacts this new request.

In `line 654`, the `index` is `1` , and in `line 657`, `lastAvailableAt` is set to `T + 1 day` due to the canceled `withdrawal`.
As a result, in `line 658`, the `availableAt` for the new `withdrawal` is calculated as `T + 1 hour`, but since this is less than `T + 1 day`, the new `withdrawal` is also pushed to be available `1 day` later.

    function pushDraft(address account, uint256 rsrAmount)
        internal
        returns (uint256 index, uint64 availableAt)
    {
        CumulativeDraft[] storage queue = draftQueues[draftEra][account];
    654:    index = queue.length;  // index = 1

        uint192 oldDrafts = index != 0 ? queue[index - 1].drafts : 0; // 0
    657:    uint64 lastAvailableAt = index != 0 ? queue[index - 1].availableAt : 0; // T + 1 day
    658:    availableAt = uint64(block.timestamp) + unstakingDelay; // T + 1 hour

        if (lastAvailableAt > availableAt) {
            availableAt = lastAvailableAt;
        }
        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));
    }

This situation is clearly unfair to the user.

The `availableAt` of `canceled withdrawals` should not be considered when determining the availability of new `withdrawals`.

Please add below test to the `test/ZZStRSR.test.ts`

```
    describe('PushDraft Test', () => {
      it('Should use current unstakingDelay', async () => {
        // old unstakingDelay is 1 day
        const oldUnstakingDelay = 3600 * 24
        await stRSR.connect(owner).setUnstakingDelay(oldUnstakingDelay)  
        const amount: BigNumber = bn('100e18')
        await rsr.connect(addr1).approve(stRSR.address, amount)
        await stRSR.connect(addr1).stake(amount)

        const draftEra = 1
        const availableAtOfFirst = await getLatestBlockTimestamp() + oldUnstakingDelay + 1
        /**
         * Unstaking request enter a queue, and withdrawal become available 1 day later
         */
        await expect(stRSR.connect(addr1).unstake(amount))
          .emit(stRSR, 'UnstakingStarted')
          .withArgs(0, draftEra, addr1.address, amount, amount, availableAtOfFirst)

        /**
         * Cancel the unstaking to eliminate any pending withdrawals
         */
        await stRSR.connect(addr1).cancelUnstake(1)

        // new unstakingDelay is 1 hour
        const newUnstakingDelay = 3600
        await stRSR.connect(owner).setUnstakingDelay(newUnstakingDelay)  

        await rsr.connect(addr2).approve(stRSR.address, amount)
        await stRSR.connect(addr2).stake(amount)

        const availableAtOfFirstOfUser2 = await getLatestBlockTimestamp() + newUnstakingDelay + 1
        /**
         * Unstaking request enter a queue, and withdrawal become available 1 hour later for a second user
         */
        await expect(stRSR.connect(addr2).unstake(amount))
          .emit(stRSR, 'UnstakingStarted')
          .withArgs(0, draftEra, addr2.address, amount, amount, availableAtOfFirstOfUser2)

        /**
         * Although the first unstaking was canceled, its available time still impacts subsequent unstaking requests
         */
        await expect(stRSR.connect(addr1).unstake(amount))
          .emit(stRSR, 'UnstakingStarted')
          .withArgs(1, draftEra, addr1.address, amount, amount, availableAtOfFirst)
      })
    })
```





