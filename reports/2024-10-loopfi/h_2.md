## [H] `CDPVault.sol#liquidatePositionBadDebt()` doesn't correctly handle profit and loss

[src/CDPVault.sol#L702](repos/2024-10-loopfi/src/CDPVault.sol#L702)

[src/PoolV3.sol#L593](repos/2024-10-loopfi/src/PoolV3.sol#L593)

When liquidating bad debt, the profit and loss is not correctly handled. This will cause incorrect accounting to lpETH stakers.

There are two issues that needs to be fixed in the new codebase:

1. The `profit` that is passed in `pool.repayCreditAccount(debtData.debt, profit, loss);` should actually use `debtData.accruedInterest`. This is because we should first "assume" full debt and interest is paid off, and calculate the loss part independently.

2. The `loss` is correctly calculated in `PoolV3#repayCreditAccount`, but the if-else branch is incorrectly implemented. Currently, it can't handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.

[CDPVault.sol#L679-L702](src/CDPVault.sol#L679-L704):

[CDPVault.sol#L679-L702](repos/2024-10-loopfi/src/CDPVault.sol#L679-L702)
```solidity
        takeCollateral = position.collateral;
        repayAmount = wmul(takeCollateral, discountedPrice);
        uint256 loss = calcTotalDebt(debtData) - repayAmount;
        uint256 profit;
        if (repayAmount > debtData.debt) {
@>          profit = repayAmount - debtData.debt;
        }
        ...
@>      pool.repayCreditAccount(debtData.debt, profit, loss); // U:[CM-11]
        // transfer the collateral amount from the vault to the liquidator
        token.safeTransfer(msg.sender, takeCollateral);

[PoolV3.sol#L572-L607](src/PoolV3.sol#L572-L607):

[PoolV3.sol#L572-L607](repos/2024-10-loopfi/src/PoolV3.sol#L572-L607)
```solidity
    function repayCreditAccount(
        uint256 repaidAmount,
        uint256 profit,
        uint256 loss
    )
        external
        override
        creditManagerOnly // U:[LP-2C]
        whenNotPaused // U:[LP-2A]
        nonReentrant // U:[LP-2B]
    {
        ...
        if (profit > 0) {
            _mint(treasury, _convertToShares(profit)); // U:[LP-14B]
@>      } else if (loss > 0) {
            address treasury_ = treasury;
            uint256 sharesInTreasury = balanceOf(treasury_);
            uint256 sharesToBurn = _convertToShares(loss);
            if (sharesToBurn > sharesInTreasury) {
                unchecked {
                    emit IncurUncoveredLoss({
                        creditManager: msg.sender,
                        loss: _convertToAssets(sharesToBurn - sharesInTreasury)
                    }); // U:[LP-14D]
                }
                sharesToBurn = sharesInTreasury;
            }
            _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]
        }
        ...
    }