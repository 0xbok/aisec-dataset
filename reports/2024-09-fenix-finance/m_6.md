## [M] Potential incorrect index update in revived gauge under specific conditions

This vulnerability could allow revived gauges to claim more rewards than intended under specific circumstances, potentially leading to unfair distribution of rewards.

The `reviveGauge` function fails to update the gauge's index to the current global index when reviving a previously killed gauge. While this issue is mitigated in most scenarios by the `distributeAll` function, which updates all gauges' indices to the global index on each epoch, a vulnerability still exists under specific conditions.

Relevant code snippet:

[VoterUpgradeableV2.sol#L250-L256](contracts/core/VoterUpgradeableV2.sol#L250-L256):
```solidity
function reviveGauge(address gauge_) external onlyRole(_GOVERNANCE_ROLE) {
    if (gaugesState[gauge_].isAlive) {
        revert GaugeNotKilled();
    }
    gaugesState[gauge_].isAlive = true;
    emit GaugeRevived(gauge_);
}
```

[VoterUpgradeableV2.sol#L626-L651](contracts/core/VoterUpgradeableV2.sol#L626-L651):
```solidity
function _distribute(address gauge_) internal {
    GaugeState memory state = gaugesState[gauge_];
    uint256 currentTimestamp = _epochTimestamp();
    if (state.lastDistributionTimestamp < currentTimestamp) {
        uint256 totalVotesWeight = weightsPerEpoch[currentTimestamp - _WEEK][state.pool];
        if (totalVotesWeight > 0) {
            uint256 delta = index - state.index; // @contest-info outdated index can cause problem here
            if (delta > 0) {
                uint256 amount = (totalVotesWeight * delta) / 1e18;
                if (state.isAlive) {
                    gaugesState[gauge_].claimable += amount;
                } else {
                    IERC20Upgradeable(token).safeTransfer(minter, amount);
                }
            }
        }
        gaugesState[gauge_].index = index;
        uint256 claimable = gaugesState[gauge_].claimable;
        if (claimable > 0 && state.isAlive) {
            gaugesState[gauge_].claimable = 0;
            gaugesState[gauge_].lastDistributionTimestamp = currentTimestamp;
            IGauge(gauge_).notifyRewardAmount(token, claimable);
            emit DistributeReward(_msgSender(), gauge_, claimable);
        }
    }
}
```

The vulnerability arises in scenarios where:

1. There's a large number of gauges in the protocol.
2. Due to gas limitations, `distributeAll` cannot update all gauges in a single transaction.
3. Manual iteration through gauges is required.
4. A killed gauge might not be updated before it's revived as there is no incentive to call `distribute` function for a killed gauge.

In this specific scenario, a revived gauge could retain an outdated index, leading to incorrect reward calculations.

### Example scenario

`Epoch x`:
- `Gauge A` is active with an index of 100.
- Global index is 100.

`Epoch x+1`:
- `Gauge A` is killed, its index stays at 100.
- Global index updates to 150.
- `distributeAll` fails to update all gauges due to gas limitations.

`Epoch x+2`:
- Before manual updates reach `Gauge A`, it is revived with index still at 100.
- Global index updates to 200.

When claiming rewards:
- `Gauge B` (updated correctly) gets `(200 - 150) * weight_B`.
- `Gauge A` incorrectly gets `(200 - 100) * weight_A`.

`Gauge A` claims excess rewards for the period it was killed. This discrepancy, while rare, could lead to unfair reward distribution for all gauges.

### Rationale on severity

High impact - Lead to loss of funds of other gauges.
Low likelihood - Only happen in specific circumstances.
Hence, Medium severity.