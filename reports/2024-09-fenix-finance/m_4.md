## [M] `boostedValue` should be added to `permanentTotalSupply` for permanently locked tokens

Unlocking tokens from the permanent locking can be DoSed.

In the `VotingEscrowUpgradeableV2._processLockChange` function, `boostedValue` is added to the token's locked amount at L465. However, `boostedValue` is not added to `permanentTotalSupply` for permanently locked tokens at L470.

[VotingEscrowUpgradeableV2.sol#L465-L471](contracts/core/VotingEscrowUpgradeableV2.sol#L465-L471):
```solidity
465:@>       newLocked.amount += LibVotingEscrowUtils.toInt128(boostedValue);
466:         uint256 diff = LibVotingEscrowUtils.toUint256(newLocked.amount - oldLocked_.amount);
467:         uint256 supplyBefore = supply;
468:         supply += diff;
469:         if (newLocked.isPermanentLocked) {
470:@>           permanentTotalSupply += amount_;
471:         }
```

In the `unlockPermanent` function, the token's locked amount is subtracted from `permanentTotalSupply` at L219.

[VotingEscrowUpgradeableV2.sol#L219](contracts/core/VotingEscrowUpgradeableV2.sol#L219):
```solidity
219:         permanentTotalSupply -= LibVotingEscrowUtils.toUint256(state.locked.amount);
```

As a result, calling this function may be reverted by the underflow.

Let's consider the following scenario:

1. Alice and Bob each create locks with 100 FNX for a 1-week duration (`< veBoostCached.getMinLockedTimeForBoost`).
2. Alice and Bob lock their tokens permanently: `permanentTotalSupply = 100 + 100 = 200`.
3. Alice deposits 1000 FNX (`>= veBoostCached.getMinFNXAmountForBoost`), and `_boostFNXPercentage` is 1000 (10%):
    - `boostedValue`: 100.
    - Total locked amount: `100 + 1000 + 100 = 1200`.
    - `permanentTotalSupply`: `200 + 1000 = 1200`.
4. Alice unlocks her token from the permanent lock: `permanentTotalSupply = 1200 - 1200 = 0`.
5. Bob tries to unlock his token from the permanent lock, but it is reverted because `permanentTotalSupply` is 0.