## [M] A dev will lose rewards if after claiming his rewards he mints an NFT

<relative_path_091409:contracts/DevFund/DevFund.sol#L69>

<relative_path_091409:contracts/DevFund/DevFund.sol#L74>

### Summary

A developer may lose rewards if the `receive` function is triggered during the reward claim process from `DevFund`, resulting in their `info.rewardDebt` being higher than expected. This scenario can occur when a developer claims their rewards and then immediately mints an NFT with the funds, but the airdrop hasnâ€™t yet started, they stand to lose those rewards. This happens because the system updates the user's `rewardDebt` after the callback.

### Vulnerability Details

When claiming the dev's rewards are calculated as follows:
`uint256 pending = info.pendingRewards +
      (totalRewardDebt - info.rewardDebt) *
      info.weight;`

Then, we do a call to that dev to transfer his funds and only after that call do we update his reward debt to the total reward debt.

This can create a flow in which the developer loses a portion of his rewards. For example, if the dev has a contract that receives his rewards and wants to use that money to then buy an NFT, as he believes in the protocol and wants to support it, he would have a `receive` function like this:

```solidity
 receive() external payable {
      traitForgeNFtContract.mintWithBudget{ value: address(this).balance }("");
 }
```

However, in this scenario the `DevFund::receive` function will be triggered (if the airdrop hasn't started) which increases `totalRewardDebt` and only after that the dev's info is updated to the `totalRewardDebt`, which means that the user will later receive less rewards because `info.rewardDebt` will include the new rewards from the received minting fees but the dev didn't claim them.

### Proof of Concept

This is `DevFund::claim()`:

```solidity
  function claim() external whenNotPaused nonReentrant {
    DevInfo storage info = devInfo[msg.sender];

    uint256 pending = info.pendingRewards +
      (totalRewardDebt - info.rewardDebt) *
      info.weight;

    if (pending > 0) {
@->      uint256 claimedAmount = safeRewardTransfer(msg.sender, pending);
      info.pendingRewards = pending - claimedAmount;
      emit Claim(msg.sender, claimedAmount);
    }

@->    info.rewardDebt = totalRewardDebt;
  }
```

We can see that the `info.rewardDebt` happens after the call to the dev, so now if the dev immediately calls the TraitForgeNft contract:

```solidity
 receive() external payable {
      traitForgeNFtContract.mintWithBudget{ value: address(this).balance }("");
 }
```

This will mint the developer some NFTs and for each minted NFT the `DevFund::receive()` will be triggered. The minting in `TraitForgeNft` distributes the fees to the `NukeFund` contract and if the airdrop hasn't started yet, the rewards are then redirected to the `DevFund` contract which triggers the `receive` function and the `totalRewardDebt` is updated:

```solidity
  receive() external payable {
    if (totalDevWeight > 0) {
      uint256 amountPerWeight = msg.value / totalDevWeight;
      uint256 remaining = msg.value - (amountPerWeight * totalDevWeight);
@->      totalRewardDebt += amountPerWeight;
      if (remaining > 0) {
        (bool success, ) = payable(owner()).call{ value: remaining }('');
        require(success, 'Failed to send Ether to owner');
      }
    } else {
      (bool success, ) = payable(owner()).call{ value: msg.value }('');
      require(success, 'Failed to send Ether to owner');
    }
    emit FundReceived(msg.sender, msg.value);
  }
```

Only after these steps we update the reward debt of the dev, which will be much higher so the developer loses the rewards from this minting fees.

Note: This scenario is more than likely to happen because the developers will want to support the protocol and participate in it.



