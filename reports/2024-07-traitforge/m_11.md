## [M] Duplicate NFT generation via repeated forging with the same parent

<relative_path_091409:contracts/EntityForging/EntityForging.sol#L102-L144>

<relative_path_091409:contracts/TraitForgeNft/TraitForgeNft.sol#L153-L179>

### Impact

It is possible to get the same NFT (same generation, same entropy) when the forging is done with the same `parentId` multiple times. Although the number of times this action will be feasible is limited with the forging potential of the token it can still occur at least once.

Scenario:

1. User A lists his/her NFT for forging.
2. User B forges his/her NFT with the NFT from User A.
3. The new NFT is created with the combined properties of the NFT1 and NFT2.
4. User A lists his/her NFT for forging again.
5. User B forges his/her NFT with the NFT from User A again.
6. The NFT will be of the same generation and will have the same entropy as the
    one forged before.

### Proof of Concept

Add this test to the `EntityForging.test.sol` contract:

    it('should not allow forging with the same parent multiple times', async () => {
          const forgerTokenId = FORGER_TOKEN_ID;
          const mergerTokenId = MERGER_TOKEN_ID;
          const fee = FORGING_FEE;

          await entityForging.connect(owner).listForForging(forgerTokenId, fee);

          const forgerEntropy = await nft.getTokenEntropy(forgerTokenId);
          const mergerEntrypy = await nft.getTokenEntropy(mergerTokenId);
          
          /// The new token id will be forger token id + 1, cause it's the last item
          const expectedTokenId = FORGER_TOKEN_ID + 1;
          await expect(
            entityForging
              .connect(user1)
              .forgeWithListed(forgerTokenId, mergerTokenId, {
                value: FORGING_FEE,
              })
          )
            .to.emit(entityForging, 'EntityForged')
            .withArgs(
              expectedTokenId,
              forgerTokenId,
              mergerTokenId,
              (forgerEntropy + mergerEntrypy) / 2n,
              FORGING_FEE
            )
            .to.emit(nft, 'NewEntityMinted')
            .withArgs(
              await user1.getAddress(),
              expectedTokenId,
              2,
              (forgerEntropy + mergerEntrypy) / 2n
            );

            // List it again
            await entityForging.connect(owner).listForForging(forgerTokenId, fee);
            const expectedId = FORGER_TOKEN_ID + 2;

            // Forge again with the same parent
            await expect(
              entityForging
                .connect(user1)
                .forgeWithListed(forgerTokenId, mergerTokenId, {
                  value: FORGING_FEE,
                })
            )
              .to.emit(entityForging, 'EntityForged')
              .withArgs(
                expectedId,
                forgerTokenId,
                mergerTokenId,
                (forgerEntropy + mergerEntrypy) / 2n,
                FORGING_FEE
              )
              .to.emit(nft, 'NewEntityMinted')
              .withArgs(
                await user1.getAddress(),
                expectedId,
                2,
                (forgerEntropy + mergerEntrypy) / 2n
              );
        });



