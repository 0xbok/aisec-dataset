## [M] Imprecise token age calculation results in an incorrect nuke factor, causing users to claim the wrong amount

The function `calculateAge()` computes the age of a token ID based on the current and creation time difference. This token age is then used to determine the [nuke factor](relative_path_091409:contracts/NukeFund/NukeFund.sol#L143) to calculate the possible claim amount.

The problem here is that when calculating the age of a token, it first divides the time difference to 1 day in seconds, and then multiplies the result to the other variables.

```solidity
  function calculateAge(uint256 tokenId) public view returns (uint256) {
    require(nftContract.ownerOf(tokenId) != address(0), 'Token does not exist');

    uint256 daysOld = (block.timestamp -
      nftContract.getTokenCreationTimestamp(tokenId)) /
      60 /
      60 /
      24;
    uint256 perfomanceFactor = nftContract.getTokenEntropy(tokenId) % 10;

    uint256 age = (daysOld *
      perfomanceFactor *
      MAX_DENOMINATOR *
      ageMultiplier) / 365; // add 5 digits for decimals
    return age;
  }
```

With having this pattern, users will face significant losses. Especially, in the case of small differences (less than 1 day), the `daysOld` variable becomes `0`, making the `age` zero respectively.

### Proof of Concept

The function below illustrates the significant discrepancies between the results:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";


contract DifferenceTest is Test {

    uint256 public constant MAX_DENOMINATOR = 100000;
    error InvalidTokenAmount();

    function setUp() public {

    }

    function calculateAge_precision(
        uint256 creationTimestamp,
        uint256 startTime,
        uint256 ageMultiplier
    )  public view returns (uint256) {

        uint256 perfomanceFactor = 150000;

        uint256 age = ((startTime - creationTimestamp) *
        perfomanceFactor *
        MAX_DENOMINATOR *
        ageMultiplier) / (60 * 60 * 24 * 365);
        return age;
    }

    function calculateAge_actual(
        uint256 creationTimestamp,
        uint256 startTime,
        uint256 ageMultiplier
    )  public view returns (uint256) {

        uint256 perfomanceFactor = 150000;

        uint256 daysOld = (startTime -
        creationTimestamp) /
        60 /
        60 /
        24;

        uint256 age = (daysOld *
        perfomanceFactor *
        MAX_DENOMINATOR *
        ageMultiplier) / 365; // add 5 digits for decimals
        return age;
    }

    function test_diffAges(
        uint256 creationTimestamp,
        uint256 startTime,
        uint256 ageMultiplier
    )  public {

        vm.assume(startTime > creationTimestamp);
        vm.assume(ageMultiplier < MAX_DENOMINATOR);
        uint actualAge = calculateAge_actual(creationTimestamp, startTime, ageMultiplier);
        uint accurateAge = calculateAge_precision(creationTimestamp, startTime, ageMultiplier);
        console.log("The actual age is:   ", actualAge);
        console.log("The accurate age is: ", accurateAge);
        assertFalse(actualAge == accurateAge);
    }
}
```

For these results we will have:

- `creationTimestamp = 1722511200`,
- `startTime = 1722799000`,
- `ageMultiplier = 150000`,
- `perfomanceFactor = 15620`:

```
[PASS] test_diffAges() (gas: 8201)
Logs:
  The actual age is:    1925753424657
  The accurate age is:  2138240106544

Traces:
  [8201] DifferenceTest::test_diffAges()
    ├─ [0] console::log("The actual age is:   ", 1925753424657 [1.925e12]) [staticcall]
    │   └─ ← [Stop]
    ├─ [0] console::log("The accurate age is: ", 2138240106544 [2.138e12]) [staticcall]
    │   └─ ← [Stop]
    ├─ [0] VM::assertFalse(false) [staticcall]
    │   └─ ← [Return]
    └─ ← [Stop]

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 520.80µs (150.20µs CPU time)
```

- The calculated age is: `1925753424657`
- The accurate age is: `2138240106544`

This will lead to `~ 11%` of errors which is a significant error here. This huge difference will also increase the nuke factor (even more) and affect the results.



